/*******************************************************************************
* Copyright 2021 Intel Corporation
*
* Licensed under the BSD-2-Clause Plus Patent License (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* https://opensource.org/licenses/BSDplusPatent
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions
* and limitations under the License.
*
*
* SPDX-License-Identifier: BSD-2-Clause-Patent
*******************************************************************************/
// The header file generated by gemm.cpp
#include "capsule-interface.h"

// Roofline utilities
#include "Roofline.h"

// The only header file needed for including T2S.
#include "HalideBuffer.h"

// For printing output
#include <stdio.h>
#include <iostream>

// For validation of results.
#include <assert.h>

// Loop bounds
#include "const-parameters.h"

#ifdef TINY // For verifying correctness only
    #define N       4
#else
    #define N       16
#endif

#define TOTAL_N     NN*N

using namespace std;

int main()
{
    Halide::Runtime::Buffer<float> P(TOTAL_CI*MK*MX, TOTAL_IY*TOTAL_IX*TOTAL_N), W(TOTAL_CO*MY, TOTAL_CI*KY*KX*MK);
    for (size_t n = 0; n < TOTAL_N; n++)
    for (size_t x = 0; x < TOTAL_IX; x++)
    for (size_t y = 0; y < TOTAL_IY; y++)
    for (size_t total_ci = 0; total_ci < TOTAL_CI; total_ci++) {
        for (size_t mx = 0; mx < MX; mx++) {
            for (size_t mk = 0; mk < MK; mk++) {
                P(total_ci+TOTAL_CI*mk+(TOTAL_CI*MK)*mx, y+TOTAL_IY*x+(TOTAL_IY*TOTAL_IX)*n) = random();
            }
        }
    }
    for (size_t kx = 0; kx < KX; kx++)
    for (size_t ky = 0; ky < KY; ky++)
    for (size_t co = 0; co < TOTAL_CO; co++)
    for (size_t ci = 0; ci < CI; ci++)
    for (size_t cii = 0; cii < CII; cii++) {
        for (size_t mk = 0; mk < MK; mk++) {
            for (size_t my = 0; my < MY; my++) {
                W(co+TOTAL_CO*my, cii+(CII)*ky+(CII*KY)*kx+(CII*KY*KX)*ci +(TOTAL_CI*KY*KX)*mk) = random();
            }
        }
    }
    Halide::Runtime::Buffer<float> V(COOO, YYY_XXX, YY_XX, Y_X, MY, MX, COO, NN, CO, N);
    capsule(P, W, V);

#ifdef TINY
    // Validate the results
    for (int n = 0; n < N; n++)
    for (int nn = 0; nn < NN; nn++)
    for (int co = 0; co < CO; co++)
    for (int coo = 0; coo < COO; coo++)
    for (int cooo = 0; cooo < COOO; cooo++)
    for (int y_x = 0; y_x < Y_X; y_x++)
    for (int yy_xx = 0; yy_xx < YY_XX; yy_xx++)
    for (int yyy_xxx = 0; yyy_xxx < YYY_XXX; yyy_xxx++)
    for (int mx = 0; mx < MX; mx++)
    for (int my = 0; my < MY; my++) {
        float golden = 0.0f;
        size_t total_oy = (yyy_xxx + YYY_XXX*yy_xx + YYY_XXX*YY_XX*y_x) % OY;
        size_t total_ox = (yyy_xxx + YYY_XXX*yy_xx + YYY_XXX*YY_XX*y_x) / OY;
        size_t total_n  = (nn + NN*n);
        for (int kx = 0; kx < KX; kx++)
        for (int ky = 0; ky < KY; ky++)
        for (int mk = 0; mk < MK; mk++)
        for (int ci = 0; ci < CI; ci++)
        for (int cii = 0; cii < CII; cii++) {
            size_t total_ci = cii  + CII*ci;
            size_t total_iy = total_oy * 2 + ky;
            size_t total_ix = total_ox * 2 + kx;
            size_t total_co = cooo + COOO*coo + COOO*COO*co;
            golden += P(total_ci+TOTAL_CI*mk+(TOTAL_CI*MK)*mx, total_iy+TOTAL_IY*total_ix+(TOTAL_IY*TOTAL_IX)*total_n)
                    * W(total_co+TOTAL_CO*my, cii+(CII)*ky+(CII*KY)*kx+(CII*KY*KX)*ci +(TOTAL_CI*KY*KX)*mk);
        }
        assert(fabs(golden - V(cooo, yyy_xxx, yy_xx, y_x, my, mx, coo, nn, co, n)) < 0.005*fabs(golden));
    }
#else
    // Report performance. DSPs, FMax and ExecTime are automatically figured out from the static analysis
    // during FPGA synthesis and and the dynamic profile during the FGPA execution.
    // A10PAC on DevCloud has 33GB/s memory bandwidth
    double mem_bandwidth = 33;
    double compute_roof = 2 * DSPs() * FMax();
     // Total operations (GFLOP for CONV), independent of designs
    double number_ops = 2 * (long)(TOTAL_N * TOTAL_CO) * (long)(MY * MX * YYY_XXX * YY_XX * Y_X) * (long)(TOTAL_CI * MK * KY * KX);
    double number_bytes = (long)(MX * MK * TOTAL_CI * TOTAL_IY * TOTAL_IX * TOTAL_N) * 4
                        + (long)(MY * MK * TOTAL_CI * TOTAL_CO * KY * KX) * 4
                        + (long)(TOTAL_CO * YYY_XXX * YY_XX * Y_X * MY * MX * TOTAL_N) * 4;
    double exec_time = ExecTime();
    roofline(mem_bandwidth, compute_roof, number_ops, number_bytes, exec_time);
    if (fopen("roofline.png", "r") == NULL) {
        cout << "Failed to draw roofline!\n";
        return 1;
    }
    cout << "Size of tensor P: " << N << ", " << TOTAL_CI << ", " << TOTAL_IX << ", " << TOTAL_IY
                                 << ", " << MX << ", " << MK << "\n";
    cout << "Size of tensor W: " << TOTAL_CI << ", " << TOTAL_CO << ", " << KX << ", " << KY
                                 << ", " << MK << ", " << MY << "\n";
#endif

    printf("Success\n");
    return 0;
}
