produce ASerializer {
 let halide_copy_to_host_result$4 = halide_copy_to_host(((halide_buffer_t *))a.buffer)
 assert((halide_copy_to_host_result$4 == 0), halide_copy_to_host_result$4)
 allocate addr.temp[int32]
 addr.temp() = 0
 for (ASerializer.s0.b, 0, a.extent.2) {
  for (ASerializer.s0.j, 0, 128) {
   for (ASerializer.s0.k, 0, 128) {
    ASerializer[addr.temp()] = (float32)a[((ASerializer.s0.b*16384) + ((ASerializer.s0.k*128) + ASerializer.s0.j))]
    addr.temp() = (addr.temp() + 1)
   }
  }
 }
 _halide_buffer_set_host_dirty(((halide_buffer_t *))ASerializer.buffer, (uint1)1)
}
consume ASerializer {
 realize ALoader.channel[0, 128], [0, 0] of type `float32' {
  produce ALoader {
   let halide_copy_to_device_result = halide_copy_to_device(((halide_buffer_t *))ASerializer.buffer, ((halide_device_interface_t *))halide_opencl_device_interface())
   assert((halide_copy_to_device_result == 0), halide_copy_to_device_result)
   parallel<OpenCL> (ALoader.s0.run_on_device, 0, 1) {
    realize addr.temp of type `int32' {
     addr.temp() = 0
     for (ALoader.s0.b, 0, a.extent.2) {
      for (ALoader.s0.j, 0, 128) {
       for (ALoader.s0.k, 0, 128) {
        (float32)write_channel("ALoader.channel", ASerializer[addr.temp()], 0)
        addr.temp() = (addr.temp() + 1)
       }
      }
     }
    }
   }
  }
  consume ALoader {
   realize AFeeder.shreg[0, 128], [0, 128] of type `float32' {
    realize R.channel[0, 0] of type `float32' {
     realize Q.shreg[0, 128], [0, 128] of type `float32' {
      realize S.shreg[0, 128] of type `float32' {
       realize irXi.shreg of type `float32' {
        realize Xi.shreg of type `float32' {
         realize X.shreg[0, 128] of type `float32' {
          realize vec_ti.shreg[0, 128] of type `float32' {
           realize A.shreg[0, 128], [0, 128] of type `float32' {
            realize vec_t.shreg[0, 128] of type `float32' {
             realize vec_ai.shreg[0, 128] of type `float32' {
              realize vec_a.shreg[0, 128] of type `float32' {
               produce R {
                parallel<OpenCL> (R.s0.run_on_device, 0, 1) {
                 produce Q {
                  parallel<OpenCL> (Q.s0.run_on_device, 0, 1) {
                   produce S {
                    parallel<OpenCL> (S.s0.run_on_device, 0, 1) {
                     produce irXi {
                      parallel<OpenCL> (irXi.s0.run_on_device, 0, 1) {
                       produce Xi {
                        parallel<OpenCL> (Xi.s0.run_on_device, 0, 1) {
                         produce X {
                          parallel<OpenCL> (X.s0.run_on_device, 0, 1) {
                           produce vec_ti {
                            parallel<OpenCL> (vec_ti.s0.run_on_device, 0, 1) {
                             produce A {
                              parallel<OpenCL> (A.s0.run_on_device, 0, 1) {
                               produce vec_t {
                                parallel<OpenCL> (vec_t.s0.run_on_device, 0, 1) {
                                 produce vec_ai {
                                  parallel<OpenCL> (vec_ai.s0.run_on_device, 0, 1) {
                                   produce vec_a {
                                    parallel<OpenCL> (vec_a.s0.run_on_device, 0, 1) {
                                     for (vec_a.s0.b, 0, a.extent.2) {
                                      parallel<OpenCL> (AFeeder.s0.run_on_device, 0, 1) {
                                       realize ALoader.scatter.temp of type `float32' {
                                        for (AFeeder.s0.j, 0, 128) {
                                         for (AFeeder.s0.k.scatter, 0, 128) {
                                          ALoader.scatter.temp() = (float32)read_channel("ALoader.channel", 0)
                                          punrolled (AFeeder.s0.k, 0, 128) {
                                           if ((AFeeder.s0.k.scatter == AFeeder.s0.k)) {
                                            (float32)write_shift_reg("AFeeder.shreg", AFeeder.s0.j, AFeeder.s0.k, ALoader.scatter.temp())
                                           }
                                           ALoader.scatter.temp() = (float32)fpga_reg(ALoader.scatter.temp())
                                          }
                                         }
                                        }
                                       }
                                      }
                                      realize i.temp of type `int32' {
                                       realize j.temp of type `int32' {
                                        i.temp() = -1
                                        j.temp() = 0
                                        annotate("Pragma", "ivdep", 64)
                                        for (vec_a.s0.ij, 0, 10400) {
                                         punrolled (vec_a.s0.k, 0, 128) {
                                          (float32)write_shift_reg("vec_a.shreg", vec_a.s0.k, select((i.temp() < 0), (float32)read_shift_reg("AFeeder.shreg", j.temp(), vec_a.s0.k), (float32)read_shift_reg("A.shreg", j.temp(), vec_a.s0.k)))
                                         }
                                         punrolled (vec_ai.s0.k, 0, 128) {
                                          (float32)write_shift_reg("vec_ai.shreg", vec_ai.s0.k, select((j.temp() == i.temp()), (float32)read_shift_reg("vec_a.shreg", vec_ai.s0.k), (float32)read_shift_reg("vec_ai.shreg", vec_ai.s0.k)))
                                         }
                                         punrolled (vec_t.s0.k, 0, 128) {
                                          (float32)write_shift_reg("vec_t.shreg", vec_t.s0.k, (select((j.temp() == i.temp()), 0.000000f, (float32)read_shift_reg("vec_a.shreg", vec_t.s0.k)) + ((float32)read_shift_reg("vec_ai.shreg", vec_t.s0.k)*select((i.temp() < 0), 0.000000f, (float32)read_shift_reg("S.shreg", j.temp())))))
                                         }
                                         punrolled (A.s0.k, 0, 128) {
                                          (float32)write_shift_reg("A.shreg", j.temp(), A.s0.k, (float32)read_shift_reg("vec_t.shreg", A.s0.k))
                                          if (((0 <= i.temp()) && (j.temp() == i.temp()))) {
                                           (float32)write_shift_reg("Q.shreg", j.temp(), A.s0.k, (float32)read_shift_reg("A.shreg", i.temp(), A.s0.k))
                                          }
                                         }
                                         punrolled (vec_ti.s0.k, 0, 128) {
                                          (float32)write_shift_reg("vec_ti.shreg", vec_ti.s0.k, select((j.temp() == (i.temp() + 1)), (float32)read_shift_reg("vec_t.shreg", vec_ti.s0.k), (float32)read_shift_reg("vec_ti.shreg", vec_ti.s0.k)))
                                         }
                                         punrolled (X.s0.k, 0, 128) {
                                          (float32)write_shift_reg("X.shreg", X.s0.k, (select((X.s0.k == 0), 0.000000f, (float32)read_shift_reg("X.shreg", (X.s0.k + -1))) + ((float32)read_shift_reg("vec_ti.shreg", X.s0.k)*(float32)read_shift_reg("vec_t.shreg", X.s0.k))))
                                         }
                                         (float32)write_shift_reg("Xi.shreg", select((j.temp() == (i.temp() + 1)), (float32)read_shift_reg("X.shreg", 127), (float32)read_shift_reg("Xi.shreg")))
                                         (float32)write_shift_reg("irXi.shreg", select((j.temp() == (i.temp() + 1)), (1.000000f/(float32)sqrt_f32((float32)read_shift_reg("X.shreg", 127))), (float32)read_shift_reg("irXi.shreg")))
                                         (float32)write_shift_reg("S.shreg", j.temp(), select((j.temp() == (i.temp() + 1)), (float32)read_shift_reg("irXi.shreg"), ((0.000000f - (float32)read_shift_reg("X.shreg", 127))/(float32)read_shift_reg("Xi.shreg"))))
                                         if ((i.temp() < j.temp())) {
                                          (float32)write_channel("R.channel", select((j.temp() == (i.temp() + 1)), (float32)sqrt_f32((float32)read_shift_reg("Xi.shreg")), ((float32)read_shift_reg("irXi.shreg")*(float32)read_shift_reg("X.shreg", 127))))
                                         }
                                         j.temp() = (j.temp() + 1)
                                         if ((j.temp() == 128)) {
                                          i.temp() = (i.temp() + 1)
                                          j.temp() = max(min(i.temp(), 64), 0)
                                         }
                                        }
                                       }
                                      }
                                      realize QCollector_gather_Q.shreg[0, 128] of type `float32' {
                                       parallel<OpenCL> (QCollector_gather_Q.run_on_device, 0, 1) {
                                        parallel<OpenCL> (QCollector.s0.run_on_device, 0, 1) {
                                         realize Q.gather.temp of type `float32' {
                                          for (QCollector.s0.j, 0, 128) {
                                           for (QCollector.s0.k.gather, 0, 128) {
                                            punrolled (QCollector.s0.k, 0, 128) {
                                             if ((QCollector.s0.k.gather == QCollector.s0.k)) {
                                              Q.gather.temp() = (float32)read_shift_reg("Q.shreg", QCollector.s0.j, QCollector.s0.k)
                                             } else {
                                              Q.gather.temp() = (float32)fpga_reg(Q.gather.temp())
                                             }
                                            }
                                            (float32)write_channel("QCollector.channel", Q.gather.temp())
                                           }
                                          }
                                         }
                                        }
                                       }
                                      }
                                     }
                                    }
                                   }
                                  }
                                 }
                                }
                               }
                              }
                             }
                            }
                           }
                          }
                         }
                        }
                       }
                      }
                     }
                    }
                   }
                  }
                 }
                }
               }
               consume R {
                consume Q {
                 consume S {
                  consume irXi {
                   consume Xi {
                    consume X {
                     consume vec_ti {
                      consume A {
                       consume vec_t {
                        consume vec_ai {
                         consume vec_a {
                          realize QCollector.channel[0, 0] of type `float32' {
                           let QUnloader.buffer = (let t66 = ((halide_dimension_t *))make_struct(0, 128, 1, 0, 0, 128, 128, 0, 0, a.extent.2, 16384, 0) in ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))alloca(size_of_halide_buffer_t()), t66, ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 3, t66, (uint64)0))
                           let halide_device_and_host_malloc_result$1 = halide_device_and_host_malloc(QUnloader.buffer, ((halide_device_interface_t *))halide_opencl_device_interface())
                           assert((halide_device_and_host_malloc_result$1 == 0), halide_device_and_host_malloc_result$1)
                           ((void *))register_destructor("halide_device_and_host_free_as_destructor", QUnloader.buffer)
                           allocate QUnloader[float32 * 128 * 128 * a.extent.2] in Heap
                            custom_new { ((void *))_halide_buffer_get_host(QUnloader.buffer) }
                            custom_delete { halide_device_host_nop_free(QUnloader); }
                           produce QUnloader {
                            let halide_device_malloc_result$1 = halide_device_malloc(QUnloader.buffer, ((halide_device_interface_t *))halide_opencl_device_interface())
                            assert((halide_device_malloc_result$1 == 0), halide_device_malloc_result$1)
                            parallel<OpenCL> (QUnloader.s0.run_on_device, 0, 1) {
                             realize addr.temp of type `int32' {
                              addr.temp() = 0
                              for (QUnloader.s0.b, 0, a.extent.2) {
                               for (QUnloader.s0.j, 0, 128) {
                                for (QUnloader.s0.k, 0, 128) {
                                 QUnloader[addr.temp()] = (float32)read_channel("QCollector.channel")
                                 addr.temp() = (addr.temp() + 1)
                                }
                               }
                              }
                             }
                            }
                            let halide_opencl_wait_for_kernels_finish_result$1 = halide_opencl_wait_for_kernels_finish()
                            assert((halide_opencl_wait_for_kernels_finish_result$1 == 0), halide_opencl_wait_for_kernels_finish_result$1)
                            _halide_buffer_set_device_dirty(QUnloader.buffer, (uint1)1)
                           }
                           consume QUnloader {
                            produce QDeserializer {
                             let halide_copy_to_host_result$1 = halide_copy_to_host(QUnloader.buffer)
                             assert((halide_copy_to_host_result$1 == 0), halide_copy_to_host_result$1)
                             let halide_copy_to_host_result$2 = halide_copy_to_host(((halide_buffer_t *))QDeserializer.buffer)
                             assert((halide_copy_to_host_result$2 == 0), halide_copy_to_host_result$2)
                             allocate addr.temp[int32]
                             addr.temp() = 0
                             for (QDeserializer.s0.b, 0, a.extent.2) {
                              for (QDeserializer.s0.j, 0, 128) {
                               for (QDeserializer.s0.k, 0, 128) {
                                QDeserializer[(((QDeserializer.s0.b*QDeserializer.stride.2) + ((QDeserializer.s0.j*QDeserializer.stride.1) + QDeserializer.s0.k)) - ((QDeserializer.min.2*QDeserializer.stride.2) + ((QDeserializer.min.1*QDeserializer.stride.1) + QDeserializer.min.0)))] = QUnloader[addr.temp()]
                                addr.temp() = (addr.temp() + 1)
                               }
                              }
                             }
                             _halide_buffer_set_host_dirty(((halide_buffer_t *))QDeserializer.buffer, (uint1)1)
                             let halide_device_and_host_free_result$1 = halide_device_and_host_free(QUnloader.buffer)
                             assert((halide_device_and_host_free_result$1 == 0), halide_device_and_host_free_result$1)
                            }
                            let RUnloader.buffer = (let t67 = ((halide_dimension_t *))make_struct(0, 128, 1, 0, 0, 128, 128, 0, 0, a.extent.2, 16384, 0) in ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))alloca(size_of_halide_buffer_t()), t67, ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 3, t67, (uint64)0))
                            let halide_device_and_host_malloc_result = halide_device_and_host_malloc(RUnloader.buffer, ((halide_device_interface_t *))halide_opencl_device_interface())
                            assert((halide_device_and_host_malloc_result == 0), halide_device_and_host_malloc_result)
                            ((void *))register_destructor("halide_device_and_host_free_as_destructor", RUnloader.buffer)
                            allocate RUnloader[float32 * 128 * 128 * a.extent.2] in Heap
                             custom_new { ((void *))_halide_buffer_get_host(RUnloader.buffer) }
                             custom_delete { halide_device_host_nop_free(RUnloader); }
                            produce RUnloader {
                             let halide_device_malloc_result = halide_device_malloc(RUnloader.buffer, ((halide_device_interface_t *))halide_opencl_device_interface())
                             assert((halide_device_malloc_result == 0), halide_device_malloc_result)
                             parallel<OpenCL> (RUnloader.s0.run_on_device, 0, 1) {
                              realize addr.temp of type `int32' {
                               addr.temp() = 0
                               for (RUnloader.s0.b, 0, a.extent.2) {
                                for (RUnloader.s0.i, 0, 128) {
                                 for (RUnloader.s0.j, RUnloader.s0.i, (128 - RUnloader.s0.i)) {
                                  RUnloader[addr.temp()] = (float32)read_channel("R.channel")
                                  addr.temp() = (addr.temp() + 1)
                                 }
                                }
                               }
                              }
                             }
                             let halide_opencl_wait_for_kernels_finish_result$2 = halide_opencl_wait_for_kernels_finish()
                             assert((halide_opencl_wait_for_kernels_finish_result$2 == 0), halide_opencl_wait_for_kernels_finish_result$2)
                             _halide_buffer_set_device_dirty(RUnloader.buffer, (uint1)1)
                            }
                            consume RUnloader {
                             produce RDeserializer {
                              let halide_copy_to_host_result = halide_copy_to_host(RUnloader.buffer)
                              assert((halide_copy_to_host_result == 0), halide_copy_to_host_result)
                              let halide_copy_to_host_result$3 = halide_copy_to_host(((halide_buffer_t *))RDeserializer.buffer)
                              assert((halide_copy_to_host_result$3 == 0), halide_copy_to_host_result$3)
                              allocate addr.temp[int32]
                              addr.temp() = 0
                              for (RDeserializer.s0.b, 0, a.extent.2) {
                               for (RDeserializer.s0.i, 0, 128) {
                                for (RDeserializer.s0.j, 0, 128) {
                                 RDeserializer[(((RDeserializer.s0.b*RDeserializer.stride.2) + ((RDeserializer.s0.i*RDeserializer.stride.1) + RDeserializer.s0.j)) - ((RDeserializer.min.2*RDeserializer.stride.2) + ((RDeserializer.min.1*RDeserializer.stride.1) + RDeserializer.min.0)))] = RUnloader[addr.temp()]
                                 addr.temp() = (addr.temp() + 1)
                                }
                               }
                              }
                              _halide_buffer_set_host_dirty(((halide_buffer_t *))RDeserializer.buffer, (uint1)1)
                              let halide_device_and_host_free_result = halide_device_and_host_free(RUnloader.buffer)
                              assert((halide_device_and_host_free_result == 0), halide_device_and_host_free_result)
                             }
                            }
                           }
                          }
                         }
                        }
                       }
                      }
                     }
                    }
                   }
                  }
                 }
                }
               }
              }
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}