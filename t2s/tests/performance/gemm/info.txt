Section: 
Section: .interp
Section: .note.ABI-tag
Section: .hash
Section: .gnu.hash
Section: .dynsym
Section: .dynstr
Section: .gnu.version
Section: .gnu.version_r
Section: .rela.dyn
Section: .rela.plt
Section: .init
Section: .plt
Section: .text
Section: .fini
Section: .rodata
Section: .eh_frame_hdr
Section: .eh_frame
Section: .gcc_except_table
Section: .init_array
Section: .fini_array
Section: .data.rel.ro
Section: .dynamic
Section: .got
Section: .got.plt
Section: .data
Section: .bss
Section: .comment
Section: .debug_aranges
Section: .debug_info
Section: .debug_abbrev
Section: .debug_line
Section: .debug_str
Section: .debug_ranges
Section: .symtab
Section: .strtab
Section: .shstrtab
User error triggered at /home/tzl/betat2sp/Halide/src/Func.cpp:1858
Warning: (at ./gemm.cpp:93) Out already has a compute_with at Z.s0.jjj. Replacing it with a new compute_with at Z.s0.kkk
User error triggered at /home/tzl/betat2sp/Halide/src/Func.cpp:1858
Warning: (at ./gemm.cpp:93) Z already has a compute_with at Y.s0.kkk. Replacing it with a new compute_with at Y.s0.kkk
User error triggered at /home/tzl/betat2sp/Halide/src/Func.cpp:1858
Warning: (at ./gemm.cpp:93) Y already has a compute_with at X.s0.kkk. Replacing it with a new compute_with at X.s0.kkk
A.gpu_fetch(k, {kkk, iii});
B.gpu_fetch(k, {kkk, jjj});
Out.gpu_store(((jjj + (8*jj)) + (64*j)), ((iii + (32*ii)) + (64*i)));
User error triggered at /home/tzl/betat2sp/Halide/../t2s/src/Stensor.cpp:689
Warning: (at ./gemm.cpp:93) Currently the GPU runtime is under developement, so we just emit out the source code in gemm_genx.cpp
User error triggered at /home/tzl/betat2sp/Halide/src/Func.cpp:1858
Warning: (at ./gemm.cpp:93) Out already has a compute_with at Z.s0.jjj. Replacing it with a new compute_with at Z.s0.kkk
User error triggered at /home/tzl/betat2sp/Halide/src/Func.cpp:1858
Warning: (at ./gemm.cpp:93) Z already has a compute_with at Y.s0.kkk. Replacing it with a new compute_with at Y.s0.kkk
User error triggered at /home/tzl/betat2sp/Halide/src/Func.cpp:1858
Warning: (at ./gemm.cpp:93) Y already has a compute_with at X.s0.kkk. Replacing it with a new compute_with at X.s0.kkk
Creating initial loop nests...
Injecting realization of { X, Y, Z, Out }
for (.__root, 0, 1) {
 realize Z[Z.kkk.min_realized, Z.kkk.extent_realized], [Z.jjj.min_realized, Z.jjj.extent_realized], [Z.iii.min_realized, Z.iii.extent_realized], [Z.jj.min_realized, Z.jj.extent_realized], [Z.ii.min_realized, Z.ii.extent_realized], [Z.kk.min_realized, Z.kk.extent_realized], [Z.k.min_realized, Z.k.extent_realized], [Z.j.min_realized, Z.j.extent_realized], [Z.i.min_realized, Z.i.extent_realized] of type `float32' {
  realize Y[Y.kkk.min_realized, Y.kkk.extent_realized], [Y.jjj.min_realized, Y.jjj.extent_realized], [Y.iii.min_realized, Y.iii.extent_realized], [Y.jj.min_realized, Y.jj.extent_realized], [Y.ii.min_realized, Y.ii.extent_realized], [Y.kk.min_realized, Y.kk.extent_realized], [Y.k.min_realized, Y.k.extent_realized], [Y.j.min_realized, Y.j.extent_realized], [Y.i.min_realized, Y.i.extent_realized] of type `float32' {
   realize X[X.kkk.min_realized, X.kkk.extent_realized], [X.jjj.min_realized, X.jjj.extent_realized], [X.iii.min_realized, X.iii.extent_realized], [X.jj.min_realized, X.jj.extent_realized], [X.ii.min_realized, X.ii.extent_realized], [X.kk.min_realized, X.kk.extent_realized], [X.k.min_realized, X.k.extent_realized], [X.j.min_realized, X.j.extent_realized], [X.i.min_realized, X.i.extent_realized] of type `float32' {
    produce Out {
     produce Z {
      produce Y {
       produce X {
        let X.s0.__outermost.loop_extent = 1
        let X.s0.__outermost.loop_max = 0
        let X.s0.__outermost.loop_min = 0
        let Y.s0.__outermost.loop_extent = 1
        let Y.s0.__outermost.loop_max = 0
        let Y.s0.__outermost.loop_min = 0
        let Z.s0.__outermost.loop_extent = 1
        let Z.s0.__outermost.loop_max = 0
        let Z.s0.__outermost.loop_min = 0
        let Out.s0.__outermost.loop_extent = 1
        let Out.s0.__outermost.loop_max = 0
        let Out.s0.__outermost.loop_min = 0
        for (X.s0.__outermost, X.s0.__outermost.loop_min, X.s0.__outermost.loop_extent) {
         let X.s0.i.loop_max = ((0 + (A.extent.1/64)) - 1)
         let X.s0.i.loop_min = 0
         let X.s0.i.loop_extent = ((((0 + (A.extent.1/64)) - 1) + 1) - 0)
         gpu_block<Default_GPU> (X.s0.i, X.s0.i.loop_min, X.s0.i.loop_extent) {
          let X.s0.j.loop_max = ((0 + (B.extent.0/64)) - 1)
          let X.s0.j.loop_min = 0
          let X.s0.j.loop_extent = ((((0 + (B.extent.0/64)) - 1) + 1) - 0)
          gpu_block<Default_GPU> (X.s0.j, X.s0.j.loop_min, X.s0.j.loop_extent) {
           let X.s0.ii.loop_max = ((0 + 2) - 1)
           let X.s0.ii.loop_min = 0
           let X.s0.ii.loop_extent = ((((0 + 2) - 1) + 1) - 0)
           gpu_thread<Default_GPU> (X.s0.ii, X.s0.ii.loop_min, X.s0.ii.loop_extent) {
            let X.s0.jj.loop_max = ((0 + 8) - 1)
            let X.s0.jj.loop_min = 0
            let X.s0.jj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
            gpu_thread<Default_GPU> (X.s0.jj, X.s0.jj.loop_min, X.s0.jj.loop_extent) {
             let X.s0.k.loop_max = ((0 + (A.extent.0/8)) - 1)
             let X.s0.k.loop_min = 0
             let X.s0.k.loop_extent = ((((0 + (A.extent.0/8)) - 1) + 1) - 0)
             for (X.s0.k, X.s0.k.loop_min, X.s0.k.loop_extent) {
              let X.s0.kk.loop_max = ((0 + 1) - 1)
              let X.s0.kk.loop_min = 0
              let X.s0.kk.loop_extent = ((((0 + 1) - 1) + 1) - 0)
              for (X.s0.kk, X.s0.kk.loop_min, X.s0.kk.loop_extent) {
               let X.s0.iii.loop_max = ((0 + 32) - 1)
               let X.s0.iii.loop_min = 0
               let X.s0.iii.loop_extent = ((((0 + 32) - 1) + 1) - 0)
               for (X.s0.iii, X.s0.iii.loop_min, X.s0.iii.loop_extent) {
                let X.s0.jjj.loop_max = ((0 + 8) - 1)
                let X.s0.jjj.loop_min = 0
                let X.s0.jjj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                vectorized (X.s0.jjj, X.s0.jjj.loop_min, X.s0.jjj.loop_extent) {
                 let X.s0.kkk.loop_max = ((0 + 8) - 1)
                 let X.s0.kkk.loop_min = 0
                 let X.s0.kkk.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                 for (X.s0.kkk, X.s0.kkk.loop_min, X.s0.kkk.loop_extent) {
                  X(X.s0.kkk, X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.kk, X.s0.k, X.s0.j, X.s0.i) = select((X.s0.jjj == 0), (float32)A_im(((X.s0.kkk + (8*X.s0.kk)) + (8*X.s0.k)), ((X.s0.iii + (32*X.s0.ii)) + (64*X.s0.i))), X(X.s0.kkk, (X.s0.jjj - 1), X.s0.iii, X.s0.jj, X.s0.ii, X.s0.kk, X.s0.k, X.s0.j, X.s0.i))
                  for (Y.s0.__outermost, Y.s0.__outermost.loop_min, Y.s0.__outermost.loop_extent) {
                   let Y.s0.i.loop_max = ((0 + (A.extent.1/64)) - 1)
                   let Y.s0.i.loop_min = 0
                   let Y.s0.i.loop_extent = ((((0 + (A.extent.1/64)) - 1) + 1) - 0)
                   let Y.s0.fused.i.loop_extent = 1
                   let Y.s0.fused.i.loop_max = X.s0.i
                   let Y.s0.fused.i.loop_min = X.s0.i
                   for (Y.s0.fused.i, Y.s0.fused.i.loop_min, Y.s0.fused.i.loop_extent) {
                    let Y.s0.j.loop_max = ((0 + (B.extent.0/64)) - 1)
                    let Y.s0.j.loop_min = 0
                    let Y.s0.j.loop_extent = ((((0 + (B.extent.0/64)) - 1) + 1) - 0)
                    let Y.s0.fused.j.loop_extent = 1
                    let Y.s0.fused.j.loop_max = X.s0.j
                    let Y.s0.fused.j.loop_min = X.s0.j
                    for (Y.s0.fused.j, Y.s0.fused.j.loop_min, Y.s0.fused.j.loop_extent) {
                     let Y.s0.ii.loop_max = ((0 + 2) - 1)
                     let Y.s0.ii.loop_min = 0
                     let Y.s0.ii.loop_extent = ((((0 + 2) - 1) + 1) - 0)
                     let Y.s0.fused.ii.loop_extent = 1
                     let Y.s0.fused.ii.loop_max = X.s0.ii
                     let Y.s0.fused.ii.loop_min = X.s0.ii
                     for (Y.s0.fused.ii, Y.s0.fused.ii.loop_min, Y.s0.fused.ii.loop_extent) {
                      let Y.s0.jj.loop_max = ((0 + 8) - 1)
                      let Y.s0.jj.loop_min = 0
                      let Y.s0.jj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                      let Y.s0.fused.jj.loop_extent = 1
                      let Y.s0.fused.jj.loop_max = X.s0.jj
                      let Y.s0.fused.jj.loop_min = X.s0.jj
                      for (Y.s0.fused.jj, Y.s0.fused.jj.loop_min, Y.s0.fused.jj.loop_extent) {
                       let Y.s0.k.loop_max = ((0 + (A.extent.0/8)) - 1)
                       let Y.s0.k.loop_min = 0
                       let Y.s0.k.loop_extent = ((((0 + (A.extent.0/8)) - 1) + 1) - 0)
                       let Y.s0.fused.k.loop_extent = 1
                       let Y.s0.fused.k.loop_max = X.s0.k
                       let Y.s0.fused.k.loop_min = X.s0.k
                       for (Y.s0.fused.k, Y.s0.fused.k.loop_min, Y.s0.fused.k.loop_extent) {
                        let Y.s0.kk.loop_max = ((0 + 1) - 1)
                        let Y.s0.kk.loop_min = 0
                        let Y.s0.kk.loop_extent = ((((0 + 1) - 1) + 1) - 0)
                        let Y.s0.fused.kk.loop_extent = 1
                        let Y.s0.fused.kk.loop_max = X.s0.kk
                        let Y.s0.fused.kk.loop_min = X.s0.kk
                        for (Y.s0.fused.kk, Y.s0.fused.kk.loop_min, Y.s0.fused.kk.loop_extent) {
                         let Y.s0.iii.loop_max = ((0 + 32) - 1)
                         let Y.s0.iii.loop_min = 0
                         let Y.s0.iii.loop_extent = ((((0 + 32) - 1) + 1) - 0)
                         let Y.s0.fused.iii.loop_extent = 1
                         let Y.s0.fused.iii.loop_max = X.s0.iii
                         let Y.s0.fused.iii.loop_min = X.s0.iii
                         for (Y.s0.fused.iii, Y.s0.fused.iii.loop_min, Y.s0.fused.iii.loop_extent) {
                          let Y.s0.jjj.loop_max = ((0 + 8) - 1)
                          let Y.s0.jjj.loop_min = 0
                          let Y.s0.jjj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                          let Y.s0.fused.jjj.loop_extent = 1
                          let Y.s0.fused.jjj.loop_max = X.s0.jjj
                          let Y.s0.fused.jjj.loop_min = X.s0.jjj
                          for (Y.s0.fused.jjj, Y.s0.fused.jjj.loop_min, Y.s0.fused.jjj.loop_extent) {
                           let Y.s0.kkk.loop_max = ((0 + 8) - 1)
                           let Y.s0.kkk.loop_min = 0
                           let Y.s0.kkk.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                           let Y.s0.fused.kkk.loop_extent = 1
                           let Y.s0.fused.kkk.loop_max = X.s0.kkk
                           let Y.s0.fused.kkk.loop_min = X.s0.kkk
                           for (Y.s0.fused.kkk, Y.s0.fused.kkk.loop_min, Y.s0.fused.kkk.loop_extent) {
                            Y(Y.s0.fused.kkk, Y.s0.fused.jjj, Y.s0.fused.iii, Y.s0.fused.jj, Y.s0.fused.ii, Y.s0.fused.kk, Y.s0.fused.k, Y.s0.fused.j, Y.s0.fused.i) = select((Y.s0.fused.iii == 0), (float32)B_im(((Y.s0.fused.jjj + (8*Y.s0.fused.jj)) + (64*Y.s0.fused.j)), ((Y.s0.fused.kkk + (8*Y.s0.fused.kk)) + (8*Y.s0.fused.k))), Y(Y.s0.fused.kkk, Y.s0.fused.jjj, (Y.s0.fused.iii - 1), Y.s0.fused.jj, Y.s0.fused.ii, Y.s0.fused.kk, Y.s0.fused.k, Y.s0.fused.j, Y.s0.fused.i))
                            for (Z.s0.__outermost, Z.s0.__outermost.loop_min, Z.s0.__outermost.loop_extent) {
                             let Z.s0.i.loop_max = ((0 + (A.extent.1/64)) - 1)
                             let Z.s0.i.loop_min = 0
                             let Z.s0.i.loop_extent = ((((0 + (A.extent.1/64)) - 1) + 1) - 0)
                             let Z.s0.fused.i.loop_extent = 1
                             let Z.s0.fused.i.loop_max = Y.s0.fused.i
                             let Z.s0.fused.i.loop_min = Y.s0.fused.i
                             for (Z.s0.fused.i, Z.s0.fused.i.loop_min, Z.s0.fused.i.loop_extent) {
                              let Z.s0.j.loop_max = ((0 + (B.extent.0/64)) - 1)
                              let Z.s0.j.loop_min = 0
                              let Z.s0.j.loop_extent = ((((0 + (B.extent.0/64)) - 1) + 1) - 0)
                              let Z.s0.fused.j.loop_extent = 1
                              let Z.s0.fused.j.loop_max = Y.s0.fused.j
                              let Z.s0.fused.j.loop_min = Y.s0.fused.j
                              for (Z.s0.fused.j, Z.s0.fused.j.loop_min, Z.s0.fused.j.loop_extent) {
                               let Z.s0.ii.loop_max = ((0 + 2) - 1)
                               let Z.s0.ii.loop_min = 0
                               let Z.s0.ii.loop_extent = ((((0 + 2) - 1) + 1) - 0)
                               let Z.s0.fused.ii.loop_extent = 1
                               let Z.s0.fused.ii.loop_max = Y.s0.fused.ii
                               let Z.s0.fused.ii.loop_min = Y.s0.fused.ii
                               for (Z.s0.fused.ii, Z.s0.fused.ii.loop_min, Z.s0.fused.ii.loop_extent) {
                                let Z.s0.jj.loop_max = ((0 + 8) - 1)
                                let Z.s0.jj.loop_min = 0
                                let Z.s0.jj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                let Z.s0.fused.jj.loop_extent = 1
                                let Z.s0.fused.jj.loop_max = Y.s0.fused.jj
                                let Z.s0.fused.jj.loop_min = Y.s0.fused.jj
                                for (Z.s0.fused.jj, Z.s0.fused.jj.loop_min, Z.s0.fused.jj.loop_extent) {
                                 let Z.s0.k.loop_max = ((0 + (A.extent.0/8)) - 1)
                                 let Z.s0.k.loop_min = 0
                                 let Z.s0.k.loop_extent = ((((0 + (A.extent.0/8)) - 1) + 1) - 0)
                                 let Z.s0.fused.k.loop_extent = 1
                                 let Z.s0.fused.k.loop_max = Y.s0.fused.k
                                 let Z.s0.fused.k.loop_min = Y.s0.fused.k
                                 for (Z.s0.fused.k, Z.s0.fused.k.loop_min, Z.s0.fused.k.loop_extent) {
                                  let Z.s0.kk.loop_max = ((0 + 1) - 1)
                                  let Z.s0.kk.loop_min = 0
                                  let Z.s0.kk.loop_extent = ((((0 + 1) - 1) + 1) - 0)
                                  let Z.s0.fused.kk.loop_extent = 1
                                  let Z.s0.fused.kk.loop_max = Y.s0.fused.kk
                                  let Z.s0.fused.kk.loop_min = Y.s0.fused.kk
                                  for (Z.s0.fused.kk, Z.s0.fused.kk.loop_min, Z.s0.fused.kk.loop_extent) {
                                   let Z.s0.iii.loop_max = ((0 + 32) - 1)
                                   let Z.s0.iii.loop_min = 0
                                   let Z.s0.iii.loop_extent = ((((0 + 32) - 1) + 1) - 0)
                                   let Z.s0.fused.iii.loop_extent = 1
                                   let Z.s0.fused.iii.loop_max = Y.s0.fused.iii
                                   let Z.s0.fused.iii.loop_min = Y.s0.fused.iii
                                   for (Z.s0.fused.iii, Z.s0.fused.iii.loop_min, Z.s0.fused.iii.loop_extent) {
                                    let Z.s0.jjj.loop_max = ((0 + 8) - 1)
                                    let Z.s0.jjj.loop_min = 0
                                    let Z.s0.jjj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                    let Z.s0.fused.jjj.loop_extent = 1
                                    let Z.s0.fused.jjj.loop_max = Y.s0.fused.jjj
                                    let Z.s0.fused.jjj.loop_min = Y.s0.fused.jjj
                                    for (Z.s0.fused.jjj, Z.s0.fused.jjj.loop_min, Z.s0.fused.jjj.loop_extent) {
                                     let Z.s0.kkk.loop_max = ((0 + 8) - 1)
                                     let Z.s0.kkk.loop_min = 0
                                     let Z.s0.kkk.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                     let Z.s0.fused.kkk.loop_extent = 1
                                     let Z.s0.fused.kkk.loop_max = Y.s0.fused.kkk
                                     let Z.s0.fused.kkk.loop_min = Y.s0.fused.kkk
                                     for (Z.s0.fused.kkk, Z.s0.fused.kkk.loop_min, Z.s0.fused.kkk.loop_extent) {
                                      Z(Z.s0.fused.kkk, Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i) = (select((((Z.s0.fused.kkk == 0) && (Z.s0.fused.kk == 0)) && (Z.s0.fused.k == 0)), 0.000000f, select((Z.s0.fused.kkk == 0), select((Z.s0.fused.kk == 0), Z(((Z.s0.fused.kkk + 8) - 1), Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, ((Z.s0.fused.kk + 1) - 1), (Z.s0.fused.k - 1), Z.s0.fused.j, Z.s0.fused.i), Z(((Z.s0.fused.kkk + 8) - 1), Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, (Z.s0.fused.kk - 1), Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i)), Z((Z.s0.fused.kkk - 1), Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i))) + (X(Z.s0.fused.kkk, Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i)*Y(Z.s0.fused.kkk, Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i)))
                                      for (Out.s0.__outermost, Out.s0.__outermost.loop_min, Out.s0.__outermost.loop_extent) {
                                       let Out.s0.i.loop_max = ((0 + (A.extent.1/64)) - 1)
                                       let Out.s0.i.loop_min = 0
                                       let Out.s0.i.loop_extent = ((((0 + (A.extent.1/64)) - 1) + 1) - 0)
                                       let Out.s0.fused.i.loop_extent = 1
                                       let Out.s0.fused.i.loop_max = Z.s0.fused.i
                                       let Out.s0.fused.i.loop_min = Z.s0.fused.i
                                       for (Out.s0.fused.i, Out.s0.fused.i.loop_min, Out.s0.fused.i.loop_extent) {
                                        let Out.s0.j.loop_max = ((0 + (B.extent.0/64)) - 1)
                                        let Out.s0.j.loop_min = 0
                                        let Out.s0.j.loop_extent = ((((0 + (B.extent.0/64)) - 1) + 1) - 0)
                                        let Out.s0.fused.j.loop_extent = 1
                                        let Out.s0.fused.j.loop_max = Z.s0.fused.j
                                        let Out.s0.fused.j.loop_min = Z.s0.fused.j
                                        for (Out.s0.fused.j, Out.s0.fused.j.loop_min, Out.s0.fused.j.loop_extent) {
                                         let Out.s0.ii.loop_max = ((0 + 2) - 1)
                                         let Out.s0.ii.loop_min = 0
                                         let Out.s0.ii.loop_extent = ((((0 + 2) - 1) + 1) - 0)
                                         let Out.s0.fused.ii.loop_extent = 1
                                         let Out.s0.fused.ii.loop_max = Z.s0.fused.ii
                                         let Out.s0.fused.ii.loop_min = Z.s0.fused.ii
                                         for (Out.s0.fused.ii, Out.s0.fused.ii.loop_min, Out.s0.fused.ii.loop_extent) {
                                          let Out.s0.jj.loop_max = ((0 + 8) - 1)
                                          let Out.s0.jj.loop_min = 0
                                          let Out.s0.jj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                          let Out.s0.fused.jj.loop_extent = 1
                                          let Out.s0.fused.jj.loop_max = Z.s0.fused.jj
                                          let Out.s0.fused.jj.loop_min = Z.s0.fused.jj
                                          for (Out.s0.fused.jj, Out.s0.fused.jj.loop_min, Out.s0.fused.jj.loop_extent) {
                                           let Out.s0.iii.loop_max = ((0 + 32) - 1)
                                           let Out.s0.iii.loop_min = 0
                                           let Out.s0.iii.loop_extent = ((((0 + 32) - 1) + 1) - 0)
                                           let Out.s0.fused.iii.loop_extent = 1
                                           let Out.s0.fused.iii.loop_max = Z.s0.fused.iii
                                           let Out.s0.fused.iii.loop_min = Z.s0.fused.iii
                                           for (Out.s0.fused.iii, Out.s0.fused.iii.loop_min, Out.s0.fused.iii.loop_extent) {
                                            let Out.s0.jjj.loop_max = ((0 + 8) - 1)
                                            let Out.s0.jjj.loop_min = 0
                                            let Out.s0.jjj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                            let Out.s0.fused.jjj.loop_extent = 1
                                            let Out.s0.fused.jjj.loop_max = Z.s0.fused.jjj
                                            let Out.s0.fused.jjj.loop_min = Z.s0.fused.jjj
                                            for (Out.s0.fused.jjj, Out.s0.fused.jjj.loop_min, Out.s0.fused.jjj.loop_extent) {
                                             Out(Out.s0.fused.jjj, Out.s0.fused.iii, Out.s0.fused.jj, Out.s0.fused.ii, Out.s0.fused.j, Out.s0.fused.i) = select((((Z.s0.fused.kkk == 7) && (Z.s0.fused.kk == 0)) && (Z.s0.fused.k == ((A.extent.0/8) - 1))), Z(Z.s0.fused.kkk, Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i))
                                            }
                                           }
                                          }
                                         }
                                        }
                                       }
                                      }
                                     }
                                    }
                                   }
                                  }
                                 }
                                }
                               }
                              }
                             }
                            }
                           }
                          }
                         }
                        }
                       }
                      }
                     }
                    }
                   }
                  }
                 }
                }
               }
              }
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
    consume Z {
     consume Y {
      consume X {
       0
      }
     }
    }
   }
  }
 }
}

Inlining B_im
for (.__root, 0, 1) {
 realize Z[Z.kkk.min_realized, Z.kkk.extent_realized], [Z.jjj.min_realized, Z.jjj.extent_realized], [Z.iii.min_realized, Z.iii.extent_realized], [Z.jj.min_realized, Z.jj.extent_realized], [Z.ii.min_realized, Z.ii.extent_realized], [Z.kk.min_realized, Z.kk.extent_realized], [Z.k.min_realized, Z.k.extent_realized], [Z.j.min_realized, Z.j.extent_realized], [Z.i.min_realized, Z.i.extent_realized] of type `float32' {
  realize Y[Y.kkk.min_realized, Y.kkk.extent_realized], [Y.jjj.min_realized, Y.jjj.extent_realized], [Y.iii.min_realized, Y.iii.extent_realized], [Y.jj.min_realized, Y.jj.extent_realized], [Y.ii.min_realized, Y.ii.extent_realized], [Y.kk.min_realized, Y.kk.extent_realized], [Y.k.min_realized, Y.k.extent_realized], [Y.j.min_realized, Y.j.extent_realized], [Y.i.min_realized, Y.i.extent_realized] of type `float32' {
   realize X[X.kkk.min_realized, X.kkk.extent_realized], [X.jjj.min_realized, X.jjj.extent_realized], [X.iii.min_realized, X.iii.extent_realized], [X.jj.min_realized, X.jj.extent_realized], [X.ii.min_realized, X.ii.extent_realized], [X.kk.min_realized, X.kk.extent_realized], [X.k.min_realized, X.k.extent_realized], [X.j.min_realized, X.j.extent_realized], [X.i.min_realized, X.i.extent_realized] of type `float32' {
    produce Out {
     produce Z {
      produce Y {
       produce X {
        let X.s0.__outermost.loop_extent = 1
        let X.s0.__outermost.loop_max = 0
        let X.s0.__outermost.loop_min = 0
        let Y.s0.__outermost.loop_extent = 1
        let Y.s0.__outermost.loop_max = 0
        let Y.s0.__outermost.loop_min = 0
        let Z.s0.__outermost.loop_extent = 1
        let Z.s0.__outermost.loop_max = 0
        let Z.s0.__outermost.loop_min = 0
        let Out.s0.__outermost.loop_extent = 1
        let Out.s0.__outermost.loop_max = 0
        let Out.s0.__outermost.loop_min = 0
        for (X.s0.__outermost, X.s0.__outermost.loop_min, X.s0.__outermost.loop_extent) {
         let X.s0.i.loop_max = ((0 + (A.extent.1/64)) - 1)
         let X.s0.i.loop_min = 0
         let X.s0.i.loop_extent = ((((0 + (A.extent.1/64)) - 1) + 1) - 0)
         gpu_block<Default_GPU> (X.s0.i, X.s0.i.loop_min, X.s0.i.loop_extent) {
          let X.s0.j.loop_max = ((0 + (B.extent.0/64)) - 1)
          let X.s0.j.loop_min = 0
          let X.s0.j.loop_extent = ((((0 + (B.extent.0/64)) - 1) + 1) - 0)
          gpu_block<Default_GPU> (X.s0.j, X.s0.j.loop_min, X.s0.j.loop_extent) {
           let X.s0.ii.loop_max = ((0 + 2) - 1)
           let X.s0.ii.loop_min = 0
           let X.s0.ii.loop_extent = ((((0 + 2) - 1) + 1) - 0)
           gpu_thread<Default_GPU> (X.s0.ii, X.s0.ii.loop_min, X.s0.ii.loop_extent) {
            let X.s0.jj.loop_max = ((0 + 8) - 1)
            let X.s0.jj.loop_min = 0
            let X.s0.jj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
            gpu_thread<Default_GPU> (X.s0.jj, X.s0.jj.loop_min, X.s0.jj.loop_extent) {
             let X.s0.k.loop_max = ((0 + (A.extent.0/8)) - 1)
             let X.s0.k.loop_min = 0
             let X.s0.k.loop_extent = ((((0 + (A.extent.0/8)) - 1) + 1) - 0)
             for (X.s0.k, X.s0.k.loop_min, X.s0.k.loop_extent) {
              let X.s0.kk.loop_max = ((0 + 1) - 1)
              let X.s0.kk.loop_min = 0
              let X.s0.kk.loop_extent = ((((0 + 1) - 1) + 1) - 0)
              for (X.s0.kk, X.s0.kk.loop_min, X.s0.kk.loop_extent) {
               let X.s0.iii.loop_max = ((0 + 32) - 1)
               let X.s0.iii.loop_min = 0
               let X.s0.iii.loop_extent = ((((0 + 32) - 1) + 1) - 0)
               for (X.s0.iii, X.s0.iii.loop_min, X.s0.iii.loop_extent) {
                let X.s0.jjj.loop_max = ((0 + 8) - 1)
                let X.s0.jjj.loop_min = 0
                let X.s0.jjj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                vectorized (X.s0.jjj, X.s0.jjj.loop_min, X.s0.jjj.loop_extent) {
                 let X.s0.kkk.loop_max = ((0 + 8) - 1)
                 let X.s0.kkk.loop_min = 0
                 let X.s0.kkk.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                 for (X.s0.kkk, X.s0.kkk.loop_min, X.s0.kkk.loop_extent) {
                  X(X.s0.kkk, X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.kk, X.s0.k, X.s0.j, X.s0.i) = select((X.s0.jjj == 0), (float32)A_im(((X.s0.kkk + (8*X.s0.kk)) + (8*X.s0.k)), ((X.s0.iii + (32*X.s0.ii)) + (64*X.s0.i))), X(X.s0.kkk, (X.s0.jjj - 1), X.s0.iii, X.s0.jj, X.s0.ii, X.s0.kk, X.s0.k, X.s0.j, X.s0.i))
                  for (Y.s0.__outermost, Y.s0.__outermost.loop_min, Y.s0.__outermost.loop_extent) {
                   let Y.s0.i.loop_max = ((0 + (A.extent.1/64)) - 1)
                   let Y.s0.i.loop_min = 0
                   let Y.s0.i.loop_extent = ((((0 + (A.extent.1/64)) - 1) + 1) - 0)
                   let Y.s0.fused.i.loop_extent = 1
                   let Y.s0.fused.i.loop_max = X.s0.i
                   let Y.s0.fused.i.loop_min = X.s0.i
                   for (Y.s0.fused.i, Y.s0.fused.i.loop_min, Y.s0.fused.i.loop_extent) {
                    let Y.s0.j.loop_max = ((0 + (B.extent.0/64)) - 1)
                    let Y.s0.j.loop_min = 0
                    let Y.s0.j.loop_extent = ((((0 + (B.extent.0/64)) - 1) + 1) - 0)
                    let Y.s0.fused.j.loop_extent = 1
                    let Y.s0.fused.j.loop_max = X.s0.j
                    let Y.s0.fused.j.loop_min = X.s0.j
                    for (Y.s0.fused.j, Y.s0.fused.j.loop_min, Y.s0.fused.j.loop_extent) {
                     let Y.s0.ii.loop_max = ((0 + 2) - 1)
                     let Y.s0.ii.loop_min = 0
                     let Y.s0.ii.loop_extent = ((((0 + 2) - 1) + 1) - 0)
                     let Y.s0.fused.ii.loop_extent = 1
                     let Y.s0.fused.ii.loop_max = X.s0.ii
                     let Y.s0.fused.ii.loop_min = X.s0.ii
                     for (Y.s0.fused.ii, Y.s0.fused.ii.loop_min, Y.s0.fused.ii.loop_extent) {
                      let Y.s0.jj.loop_max = ((0 + 8) - 1)
                      let Y.s0.jj.loop_min = 0
                      let Y.s0.jj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                      let Y.s0.fused.jj.loop_extent = 1
                      let Y.s0.fused.jj.loop_max = X.s0.jj
                      let Y.s0.fused.jj.loop_min = X.s0.jj
                      for (Y.s0.fused.jj, Y.s0.fused.jj.loop_min, Y.s0.fused.jj.loop_extent) {
                       let Y.s0.k.loop_max = ((0 + (A.extent.0/8)) - 1)
                       let Y.s0.k.loop_min = 0
                       let Y.s0.k.loop_extent = ((((0 + (A.extent.0/8)) - 1) + 1) - 0)
                       let Y.s0.fused.k.loop_extent = 1
                       let Y.s0.fused.k.loop_max = X.s0.k
                       let Y.s0.fused.k.loop_min = X.s0.k
                       for (Y.s0.fused.k, Y.s0.fused.k.loop_min, Y.s0.fused.k.loop_extent) {
                        let Y.s0.kk.loop_max = ((0 + 1) - 1)
                        let Y.s0.kk.loop_min = 0
                        let Y.s0.kk.loop_extent = ((((0 + 1) - 1) + 1) - 0)
                        let Y.s0.fused.kk.loop_extent = 1
                        let Y.s0.fused.kk.loop_max = X.s0.kk
                        let Y.s0.fused.kk.loop_min = X.s0.kk
                        for (Y.s0.fused.kk, Y.s0.fused.kk.loop_min, Y.s0.fused.kk.loop_extent) {
                         let Y.s0.iii.loop_max = ((0 + 32) - 1)
                         let Y.s0.iii.loop_min = 0
                         let Y.s0.iii.loop_extent = ((((0 + 32) - 1) + 1) - 0)
                         let Y.s0.fused.iii.loop_extent = 1
                         let Y.s0.fused.iii.loop_max = X.s0.iii
                         let Y.s0.fused.iii.loop_min = X.s0.iii
                         for (Y.s0.fused.iii, Y.s0.fused.iii.loop_min, Y.s0.fused.iii.loop_extent) {
                          let Y.s0.jjj.loop_max = ((0 + 8) - 1)
                          let Y.s0.jjj.loop_min = 0
                          let Y.s0.jjj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                          let Y.s0.fused.jjj.loop_extent = 1
                          let Y.s0.fused.jjj.loop_max = X.s0.jjj
                          let Y.s0.fused.jjj.loop_min = X.s0.jjj
                          for (Y.s0.fused.jjj, Y.s0.fused.jjj.loop_min, Y.s0.fused.jjj.loop_extent) {
                           let Y.s0.kkk.loop_max = ((0 + 8) - 1)
                           let Y.s0.kkk.loop_min = 0
                           let Y.s0.kkk.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                           let Y.s0.fused.kkk.loop_extent = 1
                           let Y.s0.fused.kkk.loop_max = X.s0.kkk
                           let Y.s0.fused.kkk.loop_min = X.s0.kkk
                           for (Y.s0.fused.kkk, Y.s0.fused.kkk.loop_min, Y.s0.fused.kkk.loop_extent) {
                            Y(Y.s0.fused.kkk, Y.s0.fused.jjj, Y.s0.fused.iii, Y.s0.fused.jj, Y.s0.fused.ii, Y.s0.fused.kk, Y.s0.fused.k, Y.s0.fused.j, Y.s0.fused.i) = select((Y.s0.fused.iii == 0), (float32)B(((Y.s0.fused.jjj + (8*Y.s0.fused.jj)) + (64*Y.s0.fused.j)), ((Y.s0.fused.kkk + (8*Y.s0.fused.kk)) + (8*Y.s0.fused.k))), Y(Y.s0.fused.kkk, Y.s0.fused.jjj, (Y.s0.fused.iii - 1), Y.s0.fused.jj, Y.s0.fused.ii, Y.s0.fused.kk, Y.s0.fused.k, Y.s0.fused.j, Y.s0.fused.i))
                            for (Z.s0.__outermost, Z.s0.__outermost.loop_min, Z.s0.__outermost.loop_extent) {
                             let Z.s0.i.loop_max = ((0 + (A.extent.1/64)) - 1)
                             let Z.s0.i.loop_min = 0
                             let Z.s0.i.loop_extent = ((((0 + (A.extent.1/64)) - 1) + 1) - 0)
                             let Z.s0.fused.i.loop_extent = 1
                             let Z.s0.fused.i.loop_max = Y.s0.fused.i
                             let Z.s0.fused.i.loop_min = Y.s0.fused.i
                             for (Z.s0.fused.i, Z.s0.fused.i.loop_min, Z.s0.fused.i.loop_extent) {
                              let Z.s0.j.loop_max = ((0 + (B.extent.0/64)) - 1)
                              let Z.s0.j.loop_min = 0
                              let Z.s0.j.loop_extent = ((((0 + (B.extent.0/64)) - 1) + 1) - 0)
                              let Z.s0.fused.j.loop_extent = 1
                              let Z.s0.fused.j.loop_max = Y.s0.fused.j
                              let Z.s0.fused.j.loop_min = Y.s0.fused.j
                              for (Z.s0.fused.j, Z.s0.fused.j.loop_min, Z.s0.fused.j.loop_extent) {
                               let Z.s0.ii.loop_max = ((0 + 2) - 1)
                               let Z.s0.ii.loop_min = 0
                               let Z.s0.ii.loop_extent = ((((0 + 2) - 1) + 1) - 0)
                               let Z.s0.fused.ii.loop_extent = 1
                               let Z.s0.fused.ii.loop_max = Y.s0.fused.ii
                               let Z.s0.fused.ii.loop_min = Y.s0.fused.ii
                               for (Z.s0.fused.ii, Z.s0.fused.ii.loop_min, Z.s0.fused.ii.loop_extent) {
                                let Z.s0.jj.loop_max = ((0 + 8) - 1)
                                let Z.s0.jj.loop_min = 0
                                let Z.s0.jj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                let Z.s0.fused.jj.loop_extent = 1
                                let Z.s0.fused.jj.loop_max = Y.s0.fused.jj
                                let Z.s0.fused.jj.loop_min = Y.s0.fused.jj
                                for (Z.s0.fused.jj, Z.s0.fused.jj.loop_min, Z.s0.fused.jj.loop_extent) {
                                 let Z.s0.k.loop_max = ((0 + (A.extent.0/8)) - 1)
                                 let Z.s0.k.loop_min = 0
                                 let Z.s0.k.loop_extent = ((((0 + (A.extent.0/8)) - 1) + 1) - 0)
                                 let Z.s0.fused.k.loop_extent = 1
                                 let Z.s0.fused.k.loop_max = Y.s0.fused.k
                                 let Z.s0.fused.k.loop_min = Y.s0.fused.k
                                 for (Z.s0.fused.k, Z.s0.fused.k.loop_min, Z.s0.fused.k.loop_extent) {
                                  let Z.s0.kk.loop_max = ((0 + 1) - 1)
                                  let Z.s0.kk.loop_min = 0
                                  let Z.s0.kk.loop_extent = ((((0 + 1) - 1) + 1) - 0)
                                  let Z.s0.fused.kk.loop_extent = 1
                                  let Z.s0.fused.kk.loop_max = Y.s0.fused.kk
                                  let Z.s0.fused.kk.loop_min = Y.s0.fused.kk
                                  for (Z.s0.fused.kk, Z.s0.fused.kk.loop_min, Z.s0.fused.kk.loop_extent) {
                                   let Z.s0.iii.loop_max = ((0 + 32) - 1)
                                   let Z.s0.iii.loop_min = 0
                                   let Z.s0.iii.loop_extent = ((((0 + 32) - 1) + 1) - 0)
                                   let Z.s0.fused.iii.loop_extent = 1
                                   let Z.s0.fused.iii.loop_max = Y.s0.fused.iii
                                   let Z.s0.fused.iii.loop_min = Y.s0.fused.iii
                                   for (Z.s0.fused.iii, Z.s0.fused.iii.loop_min, Z.s0.fused.iii.loop_extent) {
                                    let Z.s0.jjj.loop_max = ((0 + 8) - 1)
                                    let Z.s0.jjj.loop_min = 0
                                    let Z.s0.jjj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                    let Z.s0.fused.jjj.loop_extent = 1
                                    let Z.s0.fused.jjj.loop_max = Y.s0.fused.jjj
                                    let Z.s0.fused.jjj.loop_min = Y.s0.fused.jjj
                                    for (Z.s0.fused.jjj, Z.s0.fused.jjj.loop_min, Z.s0.fused.jjj.loop_extent) {
                                     let Z.s0.kkk.loop_max = ((0 + 8) - 1)
                                     let Z.s0.kkk.loop_min = 0
                                     let Z.s0.kkk.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                     let Z.s0.fused.kkk.loop_extent = 1
                                     let Z.s0.fused.kkk.loop_max = Y.s0.fused.kkk
                                     let Z.s0.fused.kkk.loop_min = Y.s0.fused.kkk
                                     for (Z.s0.fused.kkk, Z.s0.fused.kkk.loop_min, Z.s0.fused.kkk.loop_extent) {
                                      Z(Z.s0.fused.kkk, Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i) = (select((((Z.s0.fused.kkk == 0) && (Z.s0.fused.kk == 0)) && (Z.s0.fused.k == 0)), 0.000000f, select((Z.s0.fused.kkk == 0), select((Z.s0.fused.kk == 0), Z(((Z.s0.fused.kkk + 8) - 1), Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, ((Z.s0.fused.kk + 1) - 1), (Z.s0.fused.k - 1), Z.s0.fused.j, Z.s0.fused.i), Z(((Z.s0.fused.kkk + 8) - 1), Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, (Z.s0.fused.kk - 1), Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i)), Z((Z.s0.fused.kkk - 1), Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i))) + (X(Z.s0.fused.kkk, Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i)*Y(Z.s0.fused.kkk, Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i)))
                                      for (Out.s0.__outermost, Out.s0.__outermost.loop_min, Out.s0.__outermost.loop_extent) {
                                       let Out.s0.i.loop_max = ((0 + (A.extent.1/64)) - 1)
                                       let Out.s0.i.loop_min = 0
                                       let Out.s0.i.loop_extent = ((((0 + (A.extent.1/64)) - 1) + 1) - 0)
                                       let Out.s0.fused.i.loop_extent = 1
                                       let Out.s0.fused.i.loop_max = Z.s0.fused.i
                                       let Out.s0.fused.i.loop_min = Z.s0.fused.i
                                       for (Out.s0.fused.i, Out.s0.fused.i.loop_min, Out.s0.fused.i.loop_extent) {
                                        let Out.s0.j.loop_max = ((0 + (B.extent.0/64)) - 1)
                                        let Out.s0.j.loop_min = 0
                                        let Out.s0.j.loop_extent = ((((0 + (B.extent.0/64)) - 1) + 1) - 0)
                                        let Out.s0.fused.j.loop_extent = 1
                                        let Out.s0.fused.j.loop_max = Z.s0.fused.j
                                        let Out.s0.fused.j.loop_min = Z.s0.fused.j
                                        for (Out.s0.fused.j, Out.s0.fused.j.loop_min, Out.s0.fused.j.loop_extent) {
                                         let Out.s0.ii.loop_max = ((0 + 2) - 1)
                                         let Out.s0.ii.loop_min = 0
                                         let Out.s0.ii.loop_extent = ((((0 + 2) - 1) + 1) - 0)
                                         let Out.s0.fused.ii.loop_extent = 1
                                         let Out.s0.fused.ii.loop_max = Z.s0.fused.ii
                                         let Out.s0.fused.ii.loop_min = Z.s0.fused.ii
                                         for (Out.s0.fused.ii, Out.s0.fused.ii.loop_min, Out.s0.fused.ii.loop_extent) {
                                          let Out.s0.jj.loop_max = ((0 + 8) - 1)
                                          let Out.s0.jj.loop_min = 0
                                          let Out.s0.jj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                          let Out.s0.fused.jj.loop_extent = 1
                                          let Out.s0.fused.jj.loop_max = Z.s0.fused.jj
                                          let Out.s0.fused.jj.loop_min = Z.s0.fused.jj
                                          for (Out.s0.fused.jj, Out.s0.fused.jj.loop_min, Out.s0.fused.jj.loop_extent) {
                                           let Out.s0.iii.loop_max = ((0 + 32) - 1)
                                           let Out.s0.iii.loop_min = 0
                                           let Out.s0.iii.loop_extent = ((((0 + 32) - 1) + 1) - 0)
                                           let Out.s0.fused.iii.loop_extent = 1
                                           let Out.s0.fused.iii.loop_max = Z.s0.fused.iii
                                           let Out.s0.fused.iii.loop_min = Z.s0.fused.iii
                                           for (Out.s0.fused.iii, Out.s0.fused.iii.loop_min, Out.s0.fused.iii.loop_extent) {
                                            let Out.s0.jjj.loop_max = ((0 + 8) - 1)
                                            let Out.s0.jjj.loop_min = 0
                                            let Out.s0.jjj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                            let Out.s0.fused.jjj.loop_extent = 1
                                            let Out.s0.fused.jjj.loop_max = Z.s0.fused.jjj
                                            let Out.s0.fused.jjj.loop_min = Z.s0.fused.jjj
                                            for (Out.s0.fused.jjj, Out.s0.fused.jjj.loop_min, Out.s0.fused.jjj.loop_extent) {
                                             Out(Out.s0.fused.jjj, Out.s0.fused.iii, Out.s0.fused.jj, Out.s0.fused.ii, Out.s0.fused.j, Out.s0.fused.i) = select((((Z.s0.fused.kkk == 7) && (Z.s0.fused.kk == 0)) && (Z.s0.fused.k == ((A.extent.0/8) - 1))), Z(Z.s0.fused.kkk, Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i))
                                            }
                                           }
                                          }
                                         }
                                        }
                                       }
                                      }
                                     }
                                    }
                                   }
                                  }
                                 }
                                }
                               }
                              }
                             }
                            }
                           }
                          }
                         }
                        }
                       }
                      }
                     }
                    }
                   }
                  }
                 }
                }
               }
              }
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
    consume Z {
     consume Y {
      consume X {
       0
      }
     }
    }
   }
  }
 }
}

Inlining A_im
for (.__root, 0, 1) {
 realize Z[Z.kkk.min_realized, Z.kkk.extent_realized], [Z.jjj.min_realized, Z.jjj.extent_realized], [Z.iii.min_realized, Z.iii.extent_realized], [Z.jj.min_realized, Z.jj.extent_realized], [Z.ii.min_realized, Z.ii.extent_realized], [Z.kk.min_realized, Z.kk.extent_realized], [Z.k.min_realized, Z.k.extent_realized], [Z.j.min_realized, Z.j.extent_realized], [Z.i.min_realized, Z.i.extent_realized] of type `float32' {
  realize Y[Y.kkk.min_realized, Y.kkk.extent_realized], [Y.jjj.min_realized, Y.jjj.extent_realized], [Y.iii.min_realized, Y.iii.extent_realized], [Y.jj.min_realized, Y.jj.extent_realized], [Y.ii.min_realized, Y.ii.extent_realized], [Y.kk.min_realized, Y.kk.extent_realized], [Y.k.min_realized, Y.k.extent_realized], [Y.j.min_realized, Y.j.extent_realized], [Y.i.min_realized, Y.i.extent_realized] of type `float32' {
   realize X[X.kkk.min_realized, X.kkk.extent_realized], [X.jjj.min_realized, X.jjj.extent_realized], [X.iii.min_realized, X.iii.extent_realized], [X.jj.min_realized, X.jj.extent_realized], [X.ii.min_realized, X.ii.extent_realized], [X.kk.min_realized, X.kk.extent_realized], [X.k.min_realized, X.k.extent_realized], [X.j.min_realized, X.j.extent_realized], [X.i.min_realized, X.i.extent_realized] of type `float32' {
    produce Out {
     produce Z {
      produce Y {
       produce X {
        let X.s0.__outermost.loop_extent = 1
        let X.s0.__outermost.loop_max = 0
        let X.s0.__outermost.loop_min = 0
        let Y.s0.__outermost.loop_extent = 1
        let Y.s0.__outermost.loop_max = 0
        let Y.s0.__outermost.loop_min = 0
        let Z.s0.__outermost.loop_extent = 1
        let Z.s0.__outermost.loop_max = 0
        let Z.s0.__outermost.loop_min = 0
        let Out.s0.__outermost.loop_extent = 1
        let Out.s0.__outermost.loop_max = 0
        let Out.s0.__outermost.loop_min = 0
        for (X.s0.__outermost, X.s0.__outermost.loop_min, X.s0.__outermost.loop_extent) {
         let X.s0.i.loop_max = ((0 + (A.extent.1/64)) - 1)
         let X.s0.i.loop_min = 0
         let X.s0.i.loop_extent = ((((0 + (A.extent.1/64)) - 1) + 1) - 0)
         gpu_block<Default_GPU> (X.s0.i, X.s0.i.loop_min, X.s0.i.loop_extent) {
          let X.s0.j.loop_max = ((0 + (B.extent.0/64)) - 1)
          let X.s0.j.loop_min = 0
          let X.s0.j.loop_extent = ((((0 + (B.extent.0/64)) - 1) + 1) - 0)
          gpu_block<Default_GPU> (X.s0.j, X.s0.j.loop_min, X.s0.j.loop_extent) {
           let X.s0.ii.loop_max = ((0 + 2) - 1)
           let X.s0.ii.loop_min = 0
           let X.s0.ii.loop_extent = ((((0 + 2) - 1) + 1) - 0)
           gpu_thread<Default_GPU> (X.s0.ii, X.s0.ii.loop_min, X.s0.ii.loop_extent) {
            let X.s0.jj.loop_max = ((0 + 8) - 1)
            let X.s0.jj.loop_min = 0
            let X.s0.jj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
            gpu_thread<Default_GPU> (X.s0.jj, X.s0.jj.loop_min, X.s0.jj.loop_extent) {
             let X.s0.k.loop_max = ((0 + (A.extent.0/8)) - 1)
             let X.s0.k.loop_min = 0
             let X.s0.k.loop_extent = ((((0 + (A.extent.0/8)) - 1) + 1) - 0)
             for (X.s0.k, X.s0.k.loop_min, X.s0.k.loop_extent) {
              let X.s0.kk.loop_max = ((0 + 1) - 1)
              let X.s0.kk.loop_min = 0
              let X.s0.kk.loop_extent = ((((0 + 1) - 1) + 1) - 0)
              for (X.s0.kk, X.s0.kk.loop_min, X.s0.kk.loop_extent) {
               let X.s0.iii.loop_max = ((0 + 32) - 1)
               let X.s0.iii.loop_min = 0
               let X.s0.iii.loop_extent = ((((0 + 32) - 1) + 1) - 0)
               for (X.s0.iii, X.s0.iii.loop_min, X.s0.iii.loop_extent) {
                let X.s0.jjj.loop_max = ((0 + 8) - 1)
                let X.s0.jjj.loop_min = 0
                let X.s0.jjj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                vectorized (X.s0.jjj, X.s0.jjj.loop_min, X.s0.jjj.loop_extent) {
                 let X.s0.kkk.loop_max = ((0 + 8) - 1)
                 let X.s0.kkk.loop_min = 0
                 let X.s0.kkk.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                 for (X.s0.kkk, X.s0.kkk.loop_min, X.s0.kkk.loop_extent) {
                  X(X.s0.kkk, X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.kk, X.s0.k, X.s0.j, X.s0.i) = select((X.s0.jjj == 0), (float32)A(((X.s0.kkk + (8*X.s0.kk)) + (8*X.s0.k)), ((X.s0.iii + (32*X.s0.ii)) + (64*X.s0.i))), X(X.s0.kkk, (X.s0.jjj - 1), X.s0.iii, X.s0.jj, X.s0.ii, X.s0.kk, X.s0.k, X.s0.j, X.s0.i))
                  for (Y.s0.__outermost, Y.s0.__outermost.loop_min, Y.s0.__outermost.loop_extent) {
                   let Y.s0.i.loop_max = ((0 + (A.extent.1/64)) - 1)
                   let Y.s0.i.loop_min = 0
                   let Y.s0.i.loop_extent = ((((0 + (A.extent.1/64)) - 1) + 1) - 0)
                   let Y.s0.fused.i.loop_extent = 1
                   let Y.s0.fused.i.loop_max = X.s0.i
                   let Y.s0.fused.i.loop_min = X.s0.i
                   for (Y.s0.fused.i, Y.s0.fused.i.loop_min, Y.s0.fused.i.loop_extent) {
                    let Y.s0.j.loop_max = ((0 + (B.extent.0/64)) - 1)
                    let Y.s0.j.loop_min = 0
                    let Y.s0.j.loop_extent = ((((0 + (B.extent.0/64)) - 1) + 1) - 0)
                    let Y.s0.fused.j.loop_extent = 1
                    let Y.s0.fused.j.loop_max = X.s0.j
                    let Y.s0.fused.j.loop_min = X.s0.j
                    for (Y.s0.fused.j, Y.s0.fused.j.loop_min, Y.s0.fused.j.loop_extent) {
                     let Y.s0.ii.loop_max = ((0 + 2) - 1)
                     let Y.s0.ii.loop_min = 0
                     let Y.s0.ii.loop_extent = ((((0 + 2) - 1) + 1) - 0)
                     let Y.s0.fused.ii.loop_extent = 1
                     let Y.s0.fused.ii.loop_max = X.s0.ii
                     let Y.s0.fused.ii.loop_min = X.s0.ii
                     for (Y.s0.fused.ii, Y.s0.fused.ii.loop_min, Y.s0.fused.ii.loop_extent) {
                      let Y.s0.jj.loop_max = ((0 + 8) - 1)
                      let Y.s0.jj.loop_min = 0
                      let Y.s0.jj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                      let Y.s0.fused.jj.loop_extent = 1
                      let Y.s0.fused.jj.loop_max = X.s0.jj
                      let Y.s0.fused.jj.loop_min = X.s0.jj
                      for (Y.s0.fused.jj, Y.s0.fused.jj.loop_min, Y.s0.fused.jj.loop_extent) {
                       let Y.s0.k.loop_max = ((0 + (A.extent.0/8)) - 1)
                       let Y.s0.k.loop_min = 0
                       let Y.s0.k.loop_extent = ((((0 + (A.extent.0/8)) - 1) + 1) - 0)
                       let Y.s0.fused.k.loop_extent = 1
                       let Y.s0.fused.k.loop_max = X.s0.k
                       let Y.s0.fused.k.loop_min = X.s0.k
                       for (Y.s0.fused.k, Y.s0.fused.k.loop_min, Y.s0.fused.k.loop_extent) {
                        let Y.s0.kk.loop_max = ((0 + 1) - 1)
                        let Y.s0.kk.loop_min = 0
                        let Y.s0.kk.loop_extent = ((((0 + 1) - 1) + 1) - 0)
                        let Y.s0.fused.kk.loop_extent = 1
                        let Y.s0.fused.kk.loop_max = X.s0.kk
                        let Y.s0.fused.kk.loop_min = X.s0.kk
                        for (Y.s0.fused.kk, Y.s0.fused.kk.loop_min, Y.s0.fused.kk.loop_extent) {
                         let Y.s0.iii.loop_max = ((0 + 32) - 1)
                         let Y.s0.iii.loop_min = 0
                         let Y.s0.iii.loop_extent = ((((0 + 32) - 1) + 1) - 0)
                         let Y.s0.fused.iii.loop_extent = 1
                         let Y.s0.fused.iii.loop_max = X.s0.iii
                         let Y.s0.fused.iii.loop_min = X.s0.iii
                         for (Y.s0.fused.iii, Y.s0.fused.iii.loop_min, Y.s0.fused.iii.loop_extent) {
                          let Y.s0.jjj.loop_max = ((0 + 8) - 1)
                          let Y.s0.jjj.loop_min = 0
                          let Y.s0.jjj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                          let Y.s0.fused.jjj.loop_extent = 1
                          let Y.s0.fused.jjj.loop_max = X.s0.jjj
                          let Y.s0.fused.jjj.loop_min = X.s0.jjj
                          for (Y.s0.fused.jjj, Y.s0.fused.jjj.loop_min, Y.s0.fused.jjj.loop_extent) {
                           let Y.s0.kkk.loop_max = ((0 + 8) - 1)
                           let Y.s0.kkk.loop_min = 0
                           let Y.s0.kkk.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                           let Y.s0.fused.kkk.loop_extent = 1
                           let Y.s0.fused.kkk.loop_max = X.s0.kkk
                           let Y.s0.fused.kkk.loop_min = X.s0.kkk
                           for (Y.s0.fused.kkk, Y.s0.fused.kkk.loop_min, Y.s0.fused.kkk.loop_extent) {
                            Y(Y.s0.fused.kkk, Y.s0.fused.jjj, Y.s0.fused.iii, Y.s0.fused.jj, Y.s0.fused.ii, Y.s0.fused.kk, Y.s0.fused.k, Y.s0.fused.j, Y.s0.fused.i) = select((Y.s0.fused.iii == 0), (float32)B(((Y.s0.fused.jjj + (8*Y.s0.fused.jj)) + (64*Y.s0.fused.j)), ((Y.s0.fused.kkk + (8*Y.s0.fused.kk)) + (8*Y.s0.fused.k))), Y(Y.s0.fused.kkk, Y.s0.fused.jjj, (Y.s0.fused.iii - 1), Y.s0.fused.jj, Y.s0.fused.ii, Y.s0.fused.kk, Y.s0.fused.k, Y.s0.fused.j, Y.s0.fused.i))
                            for (Z.s0.__outermost, Z.s0.__outermost.loop_min, Z.s0.__outermost.loop_extent) {
                             let Z.s0.i.loop_max = ((0 + (A.extent.1/64)) - 1)
                             let Z.s0.i.loop_min = 0
                             let Z.s0.i.loop_extent = ((((0 + (A.extent.1/64)) - 1) + 1) - 0)
                             let Z.s0.fused.i.loop_extent = 1
                             let Z.s0.fused.i.loop_max = Y.s0.fused.i
                             let Z.s0.fused.i.loop_min = Y.s0.fused.i
                             for (Z.s0.fused.i, Z.s0.fused.i.loop_min, Z.s0.fused.i.loop_extent) {
                              let Z.s0.j.loop_max = ((0 + (B.extent.0/64)) - 1)
                              let Z.s0.j.loop_min = 0
                              let Z.s0.j.loop_extent = ((((0 + (B.extent.0/64)) - 1) + 1) - 0)
                              let Z.s0.fused.j.loop_extent = 1
                              let Z.s0.fused.j.loop_max = Y.s0.fused.j
                              let Z.s0.fused.j.loop_min = Y.s0.fused.j
                              for (Z.s0.fused.j, Z.s0.fused.j.loop_min, Z.s0.fused.j.loop_extent) {
                               let Z.s0.ii.loop_max = ((0 + 2) - 1)
                               let Z.s0.ii.loop_min = 0
                               let Z.s0.ii.loop_extent = ((((0 + 2) - 1) + 1) - 0)
                               let Z.s0.fused.ii.loop_extent = 1
                               let Z.s0.fused.ii.loop_max = Y.s0.fused.ii
                               let Z.s0.fused.ii.loop_min = Y.s0.fused.ii
                               for (Z.s0.fused.ii, Z.s0.fused.ii.loop_min, Z.s0.fused.ii.loop_extent) {
                                let Z.s0.jj.loop_max = ((0 + 8) - 1)
                                let Z.s0.jj.loop_min = 0
                                let Z.s0.jj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                let Z.s0.fused.jj.loop_extent = 1
                                let Z.s0.fused.jj.loop_max = Y.s0.fused.jj
                                let Z.s0.fused.jj.loop_min = Y.s0.fused.jj
                                for (Z.s0.fused.jj, Z.s0.fused.jj.loop_min, Z.s0.fused.jj.loop_extent) {
                                 let Z.s0.k.loop_max = ((0 + (A.extent.0/8)) - 1)
                                 let Z.s0.k.loop_min = 0
                                 let Z.s0.k.loop_extent = ((((0 + (A.extent.0/8)) - 1) + 1) - 0)
                                 let Z.s0.fused.k.loop_extent = 1
                                 let Z.s0.fused.k.loop_max = Y.s0.fused.k
                                 let Z.s0.fused.k.loop_min = Y.s0.fused.k
                                 for (Z.s0.fused.k, Z.s0.fused.k.loop_min, Z.s0.fused.k.loop_extent) {
                                  let Z.s0.kk.loop_max = ((0 + 1) - 1)
                                  let Z.s0.kk.loop_min = 0
                                  let Z.s0.kk.loop_extent = ((((0 + 1) - 1) + 1) - 0)
                                  let Z.s0.fused.kk.loop_extent = 1
                                  let Z.s0.fused.kk.loop_max = Y.s0.fused.kk
                                  let Z.s0.fused.kk.loop_min = Y.s0.fused.kk
                                  for (Z.s0.fused.kk, Z.s0.fused.kk.loop_min, Z.s0.fused.kk.loop_extent) {
                                   let Z.s0.iii.loop_max = ((0 + 32) - 1)
                                   let Z.s0.iii.loop_min = 0
                                   let Z.s0.iii.loop_extent = ((((0 + 32) - 1) + 1) - 0)
                                   let Z.s0.fused.iii.loop_extent = 1
                                   let Z.s0.fused.iii.loop_max = Y.s0.fused.iii
                                   let Z.s0.fused.iii.loop_min = Y.s0.fused.iii
                                   for (Z.s0.fused.iii, Z.s0.fused.iii.loop_min, Z.s0.fused.iii.loop_extent) {
                                    let Z.s0.jjj.loop_max = ((0 + 8) - 1)
                                    let Z.s0.jjj.loop_min = 0
                                    let Z.s0.jjj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                    let Z.s0.fused.jjj.loop_extent = 1
                                    let Z.s0.fused.jjj.loop_max = Y.s0.fused.jjj
                                    let Z.s0.fused.jjj.loop_min = Y.s0.fused.jjj
                                    for (Z.s0.fused.jjj, Z.s0.fused.jjj.loop_min, Z.s0.fused.jjj.loop_extent) {
                                     let Z.s0.kkk.loop_max = ((0 + 8) - 1)
                                     let Z.s0.kkk.loop_min = 0
                                     let Z.s0.kkk.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                     let Z.s0.fused.kkk.loop_extent = 1
                                     let Z.s0.fused.kkk.loop_max = Y.s0.fused.kkk
                                     let Z.s0.fused.kkk.loop_min = Y.s0.fused.kkk
                                     for (Z.s0.fused.kkk, Z.s0.fused.kkk.loop_min, Z.s0.fused.kkk.loop_extent) {
                                      Z(Z.s0.fused.kkk, Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i) = (select((((Z.s0.fused.kkk == 0) && (Z.s0.fused.kk == 0)) && (Z.s0.fused.k == 0)), 0.000000f, select((Z.s0.fused.kkk == 0), select((Z.s0.fused.kk == 0), Z(((Z.s0.fused.kkk + 8) - 1), Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, ((Z.s0.fused.kk + 1) - 1), (Z.s0.fused.k - 1), Z.s0.fused.j, Z.s0.fused.i), Z(((Z.s0.fused.kkk + 8) - 1), Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, (Z.s0.fused.kk - 1), Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i)), Z((Z.s0.fused.kkk - 1), Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i))) + (X(Z.s0.fused.kkk, Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i)*Y(Z.s0.fused.kkk, Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i)))
                                      for (Out.s0.__outermost, Out.s0.__outermost.loop_min, Out.s0.__outermost.loop_extent) {
                                       let Out.s0.i.loop_max = ((0 + (A.extent.1/64)) - 1)
                                       let Out.s0.i.loop_min = 0
                                       let Out.s0.i.loop_extent = ((((0 + (A.extent.1/64)) - 1) + 1) - 0)
                                       let Out.s0.fused.i.loop_extent = 1
                                       let Out.s0.fused.i.loop_max = Z.s0.fused.i
                                       let Out.s0.fused.i.loop_min = Z.s0.fused.i
                                       for (Out.s0.fused.i, Out.s0.fused.i.loop_min, Out.s0.fused.i.loop_extent) {
                                        let Out.s0.j.loop_max = ((0 + (B.extent.0/64)) - 1)
                                        let Out.s0.j.loop_min = 0
                                        let Out.s0.j.loop_extent = ((((0 + (B.extent.0/64)) - 1) + 1) - 0)
                                        let Out.s0.fused.j.loop_extent = 1
                                        let Out.s0.fused.j.loop_max = Z.s0.fused.j
                                        let Out.s0.fused.j.loop_min = Z.s0.fused.j
                                        for (Out.s0.fused.j, Out.s0.fused.j.loop_min, Out.s0.fused.j.loop_extent) {
                                         let Out.s0.ii.loop_max = ((0 + 2) - 1)
                                         let Out.s0.ii.loop_min = 0
                                         let Out.s0.ii.loop_extent = ((((0 + 2) - 1) + 1) - 0)
                                         let Out.s0.fused.ii.loop_extent = 1
                                         let Out.s0.fused.ii.loop_max = Z.s0.fused.ii
                                         let Out.s0.fused.ii.loop_min = Z.s0.fused.ii
                                         for (Out.s0.fused.ii, Out.s0.fused.ii.loop_min, Out.s0.fused.ii.loop_extent) {
                                          let Out.s0.jj.loop_max = ((0 + 8) - 1)
                                          let Out.s0.jj.loop_min = 0
                                          let Out.s0.jj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                          let Out.s0.fused.jj.loop_extent = 1
                                          let Out.s0.fused.jj.loop_max = Z.s0.fused.jj
                                          let Out.s0.fused.jj.loop_min = Z.s0.fused.jj
                                          for (Out.s0.fused.jj, Out.s0.fused.jj.loop_min, Out.s0.fused.jj.loop_extent) {
                                           let Out.s0.iii.loop_max = ((0 + 32) - 1)
                                           let Out.s0.iii.loop_min = 0
                                           let Out.s0.iii.loop_extent = ((((0 + 32) - 1) + 1) - 0)
                                           let Out.s0.fused.iii.loop_extent = 1
                                           let Out.s0.fused.iii.loop_max = Z.s0.fused.iii
                                           let Out.s0.fused.iii.loop_min = Z.s0.fused.iii
                                           for (Out.s0.fused.iii, Out.s0.fused.iii.loop_min, Out.s0.fused.iii.loop_extent) {
                                            let Out.s0.jjj.loop_max = ((0 + 8) - 1)
                                            let Out.s0.jjj.loop_min = 0
                                            let Out.s0.jjj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                            let Out.s0.fused.jjj.loop_extent = 1
                                            let Out.s0.fused.jjj.loop_max = Z.s0.fused.jjj
                                            let Out.s0.fused.jjj.loop_min = Z.s0.fused.jjj
                                            for (Out.s0.fused.jjj, Out.s0.fused.jjj.loop_min, Out.s0.fused.jjj.loop_extent) {
                                             Out(Out.s0.fused.jjj, Out.s0.fused.iii, Out.s0.fused.jj, Out.s0.fused.ii, Out.s0.fused.j, Out.s0.fused.i) = select((((Z.s0.fused.kkk == 7) && (Z.s0.fused.kk == 0)) && (Z.s0.fused.k == ((A.extent.0/8) - 1))), Z(Z.s0.fused.kkk, Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i))
                                            }
                                           }
                                          }
                                         }
                                        }
                                       }
                                      }
                                     }
                                    }
                                   }
                                  }
                                 }
                                }
                               }
                              }
                             }
                            }
                           }
                          }
                         }
                        }
                       }
                      }
                     }
                    }
                   }
                  }
                 }
                }
               }
              }
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
    consume Z {
     consume Y {
      consume X {
       0
      }
     }
    }
   }
  }
 }
}

Lowering after creating initial loop nests:
realize Z[Z.kkk.min_realized, Z.kkk.extent_realized], [Z.jjj.min_realized, Z.jjj.extent_realized], [Z.iii.min_realized, Z.iii.extent_realized], [Z.jj.min_realized, Z.jj.extent_realized], [Z.ii.min_realized, Z.ii.extent_realized], [Z.kk.min_realized, Z.kk.extent_realized], [Z.k.min_realized, Z.k.extent_realized], [Z.j.min_realized, Z.j.extent_realized], [Z.i.min_realized, Z.i.extent_realized] of type `float32' {
 realize Y[Y.kkk.min_realized, Y.kkk.extent_realized], [Y.jjj.min_realized, Y.jjj.extent_realized], [Y.iii.min_realized, Y.iii.extent_realized], [Y.jj.min_realized, Y.jj.extent_realized], [Y.ii.min_realized, Y.ii.extent_realized], [Y.kk.min_realized, Y.kk.extent_realized], [Y.k.min_realized, Y.k.extent_realized], [Y.j.min_realized, Y.j.extent_realized], [Y.i.min_realized, Y.i.extent_realized] of type `float32' {
  realize X[X.kkk.min_realized, X.kkk.extent_realized], [X.jjj.min_realized, X.jjj.extent_realized], [X.iii.min_realized, X.iii.extent_realized], [X.jj.min_realized, X.jj.extent_realized], [X.ii.min_realized, X.ii.extent_realized], [X.kk.min_realized, X.kk.extent_realized], [X.k.min_realized, X.k.extent_realized], [X.j.min_realized, X.j.extent_realized], [X.i.min_realized, X.i.extent_realized] of type `float32' {
   produce Out {
    produce Z {
     produce Y {
      produce X {
       let X.s0.i.loop_max = ((0 + (A.extent.1/64)) - 1)
       let X.s0.i.loop_min = 0
       let X.s0.i.loop_extent = ((((0 + (A.extent.1/64)) - 1) + 1) - 0)
       gpu_block<Default_GPU> (X.s0.i, X.s0.i.loop_min, X.s0.i.loop_extent) {
        let X.s0.j.loop_max = ((0 + (B.extent.0/64)) - 1)
        let X.s0.j.loop_min = 0
        let X.s0.j.loop_extent = ((((0 + (B.extent.0/64)) - 1) + 1) - 0)
        gpu_block<Default_GPU> (X.s0.j, X.s0.j.loop_min, X.s0.j.loop_extent) {
         let X.s0.ii.loop_max = ((0 + 2) - 1)
         let X.s0.ii.loop_min = 0
         let X.s0.ii.loop_extent = ((((0 + 2) - 1) + 1) - 0)
         gpu_thread<Default_GPU> (X.s0.ii, X.s0.ii.loop_min, X.s0.ii.loop_extent) {
          let X.s0.jj.loop_max = ((0 + 8) - 1)
          let X.s0.jj.loop_min = 0
          let X.s0.jj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
          gpu_thread<Default_GPU> (X.s0.jj, X.s0.jj.loop_min, X.s0.jj.loop_extent) {
           let X.s0.k.loop_max = ((0 + (A.extent.0/8)) - 1)
           let X.s0.k.loop_min = 0
           let X.s0.k.loop_extent = ((((0 + (A.extent.0/8)) - 1) + 1) - 0)
           for (X.s0.k, X.s0.k.loop_min, X.s0.k.loop_extent) {
            let X.s0.kk.loop_max = ((0 + 1) - 1)
            let X.s0.kk.loop_min = 0
            let X.s0.kk.loop_extent = ((((0 + 1) - 1) + 1) - 0)
            for (X.s0.kk, X.s0.kk.loop_min, X.s0.kk.loop_extent) {
             let X.s0.iii.loop_max = ((0 + 32) - 1)
             let X.s0.iii.loop_min = 0
             let X.s0.iii.loop_extent = ((((0 + 32) - 1) + 1) - 0)
             for (X.s0.iii, X.s0.iii.loop_min, X.s0.iii.loop_extent) {
              let X.s0.jjj.loop_max = ((0 + 8) - 1)
              let X.s0.jjj.loop_min = 0
              let X.s0.jjj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
              vectorized (X.s0.jjj, X.s0.jjj.loop_min, X.s0.jjj.loop_extent) {
               let X.s0.kkk.loop_max = ((0 + 8) - 1)
               let X.s0.kkk.loop_min = 0
               let X.s0.kkk.loop_extent = ((((0 + 8) - 1) + 1) - 0)
               for (X.s0.kkk, X.s0.kkk.loop_min, X.s0.kkk.loop_extent) {
                X(X.s0.kkk, X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.kk, X.s0.k, X.s0.j, X.s0.i) = select((X.s0.jjj == 0), (float32)A(((X.s0.kkk + (8*X.s0.kk)) + (8*X.s0.k)), ((X.s0.iii + (32*X.s0.ii)) + (64*X.s0.i))), X(X.s0.kkk, (X.s0.jjj - 1), X.s0.iii, X.s0.jj, X.s0.ii, X.s0.kk, X.s0.k, X.s0.j, X.s0.i))
                let Y.s0.i.loop_max = ((0 + (A.extent.1/64)) - 1)
                let Y.s0.i.loop_min = 0
                let Y.s0.i.loop_extent = ((((0 + (A.extent.1/64)) - 1) + 1) - 0)
                let Y.s0.fused.i.loop_extent = 1
                let Y.s0.fused.i.loop_max = X.s0.i
                let Y.s0.fused.i.loop_min = X.s0.i
                for (Y.s0.fused.i, Y.s0.fused.i.loop_min, Y.s0.fused.i.loop_extent) {
                 let Y.s0.j.loop_max = ((0 + (B.extent.0/64)) - 1)
                 let Y.s0.j.loop_min = 0
                 let Y.s0.j.loop_extent = ((((0 + (B.extent.0/64)) - 1) + 1) - 0)
                 let Y.s0.fused.j.loop_extent = 1
                 let Y.s0.fused.j.loop_max = X.s0.j
                 let Y.s0.fused.j.loop_min = X.s0.j
                 for (Y.s0.fused.j, Y.s0.fused.j.loop_min, Y.s0.fused.j.loop_extent) {
                  let Y.s0.ii.loop_max = ((0 + 2) - 1)
                  let Y.s0.ii.loop_min = 0
                  let Y.s0.ii.loop_extent = ((((0 + 2) - 1) + 1) - 0)
                  let Y.s0.fused.ii.loop_extent = 1
                  let Y.s0.fused.ii.loop_max = X.s0.ii
                  let Y.s0.fused.ii.loop_min = X.s0.ii
                  for (Y.s0.fused.ii, Y.s0.fused.ii.loop_min, Y.s0.fused.ii.loop_extent) {
                   let Y.s0.jj.loop_max = ((0 + 8) - 1)
                   let Y.s0.jj.loop_min = 0
                   let Y.s0.jj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                   let Y.s0.fused.jj.loop_extent = 1
                   let Y.s0.fused.jj.loop_max = X.s0.jj
                   let Y.s0.fused.jj.loop_min = X.s0.jj
                   for (Y.s0.fused.jj, Y.s0.fused.jj.loop_min, Y.s0.fused.jj.loop_extent) {
                    let Y.s0.k.loop_max = ((0 + (A.extent.0/8)) - 1)
                    let Y.s0.k.loop_min = 0
                    let Y.s0.k.loop_extent = ((((0 + (A.extent.0/8)) - 1) + 1) - 0)
                    let Y.s0.fused.k.loop_extent = 1
                    let Y.s0.fused.k.loop_max = X.s0.k
                    let Y.s0.fused.k.loop_min = X.s0.k
                    for (Y.s0.fused.k, Y.s0.fused.k.loop_min, Y.s0.fused.k.loop_extent) {
                     let Y.s0.kk.loop_max = ((0 + 1) - 1)
                     let Y.s0.kk.loop_min = 0
                     let Y.s0.kk.loop_extent = ((((0 + 1) - 1) + 1) - 0)
                     let Y.s0.fused.kk.loop_extent = 1
                     let Y.s0.fused.kk.loop_max = X.s0.kk
                     let Y.s0.fused.kk.loop_min = X.s0.kk
                     for (Y.s0.fused.kk, Y.s0.fused.kk.loop_min, Y.s0.fused.kk.loop_extent) {
                      let Y.s0.iii.loop_max = ((0 + 32) - 1)
                      let Y.s0.iii.loop_min = 0
                      let Y.s0.iii.loop_extent = ((((0 + 32) - 1) + 1) - 0)
                      let Y.s0.fused.iii.loop_extent = 1
                      let Y.s0.fused.iii.loop_max = X.s0.iii
                      let Y.s0.fused.iii.loop_min = X.s0.iii
                      for (Y.s0.fused.iii, Y.s0.fused.iii.loop_min, Y.s0.fused.iii.loop_extent) {
                       let Y.s0.jjj.loop_max = ((0 + 8) - 1)
                       let Y.s0.jjj.loop_min = 0
                       let Y.s0.jjj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                       let Y.s0.fused.jjj.loop_extent = 1
                       let Y.s0.fused.jjj.loop_max = X.s0.jjj
                       let Y.s0.fused.jjj.loop_min = X.s0.jjj
                       for (Y.s0.fused.jjj, Y.s0.fused.jjj.loop_min, Y.s0.fused.jjj.loop_extent) {
                        let Y.s0.kkk.loop_max = ((0 + 8) - 1)
                        let Y.s0.kkk.loop_min = 0
                        let Y.s0.kkk.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                        let Y.s0.fused.kkk.loop_extent = 1
                        let Y.s0.fused.kkk.loop_max = X.s0.kkk
                        let Y.s0.fused.kkk.loop_min = X.s0.kkk
                        for (Y.s0.fused.kkk, Y.s0.fused.kkk.loop_min, Y.s0.fused.kkk.loop_extent) {
                         Y(Y.s0.fused.kkk, Y.s0.fused.jjj, Y.s0.fused.iii, Y.s0.fused.jj, Y.s0.fused.ii, Y.s0.fused.kk, Y.s0.fused.k, Y.s0.fused.j, Y.s0.fused.i) = select((Y.s0.fused.iii == 0), (float32)B(((Y.s0.fused.jjj + (8*Y.s0.fused.jj)) + (64*Y.s0.fused.j)), ((Y.s0.fused.kkk + (8*Y.s0.fused.kk)) + (8*Y.s0.fused.k))), Y(Y.s0.fused.kkk, Y.s0.fused.jjj, (Y.s0.fused.iii - 1), Y.s0.fused.jj, Y.s0.fused.ii, Y.s0.fused.kk, Y.s0.fused.k, Y.s0.fused.j, Y.s0.fused.i))
                         let Z.s0.i.loop_max = ((0 + (A.extent.1/64)) - 1)
                         let Z.s0.i.loop_min = 0
                         let Z.s0.i.loop_extent = ((((0 + (A.extent.1/64)) - 1) + 1) - 0)
                         let Z.s0.fused.i.loop_extent = 1
                         let Z.s0.fused.i.loop_max = Y.s0.fused.i
                         let Z.s0.fused.i.loop_min = Y.s0.fused.i
                         for (Z.s0.fused.i, Z.s0.fused.i.loop_min, Z.s0.fused.i.loop_extent) {
                          let Z.s0.j.loop_max = ((0 + (B.extent.0/64)) - 1)
                          let Z.s0.j.loop_min = 0
                          let Z.s0.j.loop_extent = ((((0 + (B.extent.0/64)) - 1) + 1) - 0)
                          let Z.s0.fused.j.loop_extent = 1
                          let Z.s0.fused.j.loop_max = Y.s0.fused.j
                          let Z.s0.fused.j.loop_min = Y.s0.fused.j
                          for (Z.s0.fused.j, Z.s0.fused.j.loop_min, Z.s0.fused.j.loop_extent) {
                           let Z.s0.ii.loop_max = ((0 + 2) - 1)
                           let Z.s0.ii.loop_min = 0
                           let Z.s0.ii.loop_extent = ((((0 + 2) - 1) + 1) - 0)
                           let Z.s0.fused.ii.loop_extent = 1
                           let Z.s0.fused.ii.loop_max = Y.s0.fused.ii
                           let Z.s0.fused.ii.loop_min = Y.s0.fused.ii
                           for (Z.s0.fused.ii, Z.s0.fused.ii.loop_min, Z.s0.fused.ii.loop_extent) {
                            let Z.s0.jj.loop_max = ((0 + 8) - 1)
                            let Z.s0.jj.loop_min = 0
                            let Z.s0.jj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                            let Z.s0.fused.jj.loop_extent = 1
                            let Z.s0.fused.jj.loop_max = Y.s0.fused.jj
                            let Z.s0.fused.jj.loop_min = Y.s0.fused.jj
                            for (Z.s0.fused.jj, Z.s0.fused.jj.loop_min, Z.s0.fused.jj.loop_extent) {
                             let Z.s0.k.loop_max = ((0 + (A.extent.0/8)) - 1)
                             let Z.s0.k.loop_min = 0
                             let Z.s0.k.loop_extent = ((((0 + (A.extent.0/8)) - 1) + 1) - 0)
                             let Z.s0.fused.k.loop_extent = 1
                             let Z.s0.fused.k.loop_max = Y.s0.fused.k
                             let Z.s0.fused.k.loop_min = Y.s0.fused.k
                             for (Z.s0.fused.k, Z.s0.fused.k.loop_min, Z.s0.fused.k.loop_extent) {
                              let Z.s0.kk.loop_max = ((0 + 1) - 1)
                              let Z.s0.kk.loop_min = 0
                              let Z.s0.kk.loop_extent = ((((0 + 1) - 1) + 1) - 0)
                              let Z.s0.fused.kk.loop_extent = 1
                              let Z.s0.fused.kk.loop_max = Y.s0.fused.kk
                              let Z.s0.fused.kk.loop_min = Y.s0.fused.kk
                              for (Z.s0.fused.kk, Z.s0.fused.kk.loop_min, Z.s0.fused.kk.loop_extent) {
                               let Z.s0.iii.loop_max = ((0 + 32) - 1)
                               let Z.s0.iii.loop_min = 0
                               let Z.s0.iii.loop_extent = ((((0 + 32) - 1) + 1) - 0)
                               let Z.s0.fused.iii.loop_extent = 1
                               let Z.s0.fused.iii.loop_max = Y.s0.fused.iii
                               let Z.s0.fused.iii.loop_min = Y.s0.fused.iii
                               for (Z.s0.fused.iii, Z.s0.fused.iii.loop_min, Z.s0.fused.iii.loop_extent) {
                                let Z.s0.jjj.loop_max = ((0 + 8) - 1)
                                let Z.s0.jjj.loop_min = 0
                                let Z.s0.jjj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                let Z.s0.fused.jjj.loop_extent = 1
                                let Z.s0.fused.jjj.loop_max = Y.s0.fused.jjj
                                let Z.s0.fused.jjj.loop_min = Y.s0.fused.jjj
                                for (Z.s0.fused.jjj, Z.s0.fused.jjj.loop_min, Z.s0.fused.jjj.loop_extent) {
                                 let Z.s0.kkk.loop_max = ((0 + 8) - 1)
                                 let Z.s0.kkk.loop_min = 0
                                 let Z.s0.kkk.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                 let Z.s0.fused.kkk.loop_extent = 1
                                 let Z.s0.fused.kkk.loop_max = Y.s0.fused.kkk
                                 let Z.s0.fused.kkk.loop_min = Y.s0.fused.kkk
                                 for (Z.s0.fused.kkk, Z.s0.fused.kkk.loop_min, Z.s0.fused.kkk.loop_extent) {
                                  Z(Z.s0.fused.kkk, Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i) = (select((((Z.s0.fused.kkk == 0) && (Z.s0.fused.kk == 0)) && (Z.s0.fused.k == 0)), 0.000000f, select((Z.s0.fused.kkk == 0), select((Z.s0.fused.kk == 0), Z(((Z.s0.fused.kkk + 8) - 1), Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, ((Z.s0.fused.kk + 1) - 1), (Z.s0.fused.k - 1), Z.s0.fused.j, Z.s0.fused.i), Z(((Z.s0.fused.kkk + 8) - 1), Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, (Z.s0.fused.kk - 1), Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i)), Z((Z.s0.fused.kkk - 1), Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i))) + (X(Z.s0.fused.kkk, Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i)*Y(Z.s0.fused.kkk, Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i)))
                                  let Out.s0.i.loop_max = ((0 + (A.extent.1/64)) - 1)
                                  let Out.s0.i.loop_min = 0
                                  let Out.s0.i.loop_extent = ((((0 + (A.extent.1/64)) - 1) + 1) - 0)
                                  let Out.s0.fused.i.loop_extent = 1
                                  let Out.s0.fused.i.loop_max = Z.s0.fused.i
                                  let Out.s0.fused.i.loop_min = Z.s0.fused.i
                                  for (Out.s0.fused.i, Out.s0.fused.i.loop_min, Out.s0.fused.i.loop_extent) {
                                   let Out.s0.j.loop_max = ((0 + (B.extent.0/64)) - 1)
                                   let Out.s0.j.loop_min = 0
                                   let Out.s0.j.loop_extent = ((((0 + (B.extent.0/64)) - 1) + 1) - 0)
                                   let Out.s0.fused.j.loop_extent = 1
                                   let Out.s0.fused.j.loop_max = Z.s0.fused.j
                                   let Out.s0.fused.j.loop_min = Z.s0.fused.j
                                   for (Out.s0.fused.j, Out.s0.fused.j.loop_min, Out.s0.fused.j.loop_extent) {
                                    let Out.s0.ii.loop_max = ((0 + 2) - 1)
                                    let Out.s0.ii.loop_min = 0
                                    let Out.s0.ii.loop_extent = ((((0 + 2) - 1) + 1) - 0)
                                    let Out.s0.fused.ii.loop_extent = 1
                                    let Out.s0.fused.ii.loop_max = Z.s0.fused.ii
                                    let Out.s0.fused.ii.loop_min = Z.s0.fused.ii
                                    for (Out.s0.fused.ii, Out.s0.fused.ii.loop_min, Out.s0.fused.ii.loop_extent) {
                                     let Out.s0.jj.loop_max = ((0 + 8) - 1)
                                     let Out.s0.jj.loop_min = 0
                                     let Out.s0.jj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                     let Out.s0.fused.jj.loop_extent = 1
                                     let Out.s0.fused.jj.loop_max = Z.s0.fused.jj
                                     let Out.s0.fused.jj.loop_min = Z.s0.fused.jj
                                     for (Out.s0.fused.jj, Out.s0.fused.jj.loop_min, Out.s0.fused.jj.loop_extent) {
                                      let Out.s0.iii.loop_max = ((0 + 32) - 1)
                                      let Out.s0.iii.loop_min = 0
                                      let Out.s0.iii.loop_extent = ((((0 + 32) - 1) + 1) - 0)
                                      let Out.s0.fused.iii.loop_extent = 1
                                      let Out.s0.fused.iii.loop_max = Z.s0.fused.iii
                                      let Out.s0.fused.iii.loop_min = Z.s0.fused.iii
                                      for (Out.s0.fused.iii, Out.s0.fused.iii.loop_min, Out.s0.fused.iii.loop_extent) {
                                       let Out.s0.jjj.loop_max = ((0 + 8) - 1)
                                       let Out.s0.jjj.loop_min = 0
                                       let Out.s0.jjj.loop_extent = ((((0 + 8) - 1) + 1) - 0)
                                       let Out.s0.fused.jjj.loop_extent = 1
                                       let Out.s0.fused.jjj.loop_max = Z.s0.fused.jjj
                                       let Out.s0.fused.jjj.loop_min = Z.s0.fused.jjj
                                       for (Out.s0.fused.jjj, Out.s0.fused.jjj.loop_min, Out.s0.fused.jjj.loop_extent) {
                                        Out(Out.s0.fused.jjj, Out.s0.fused.iii, Out.s0.fused.jj, Out.s0.fused.ii, Out.s0.fused.j, Out.s0.fused.i) = select((((Z.s0.fused.kkk == 7) && (Z.s0.fused.kk == 0)) && (Z.s0.fused.k == ((A.extent.0/8) - 1))), Z(Z.s0.fused.kkk, Z.s0.fused.jjj, Z.s0.fused.iii, Z.s0.fused.jj, Z.s0.fused.ii, Z.s0.fused.kk, Z.s0.fused.k, Z.s0.fused.j, Z.s0.fused.i))
                                       }
                                      }
                                     }
                                    }
                                   }
                                  }
                                 }
                                }
                               }
                              }
                             }
                            }
                           }
                          }
                         }
                        }
                       }
                      }
                     }
                    }
                   }
                  }
                 }
                }
               }
              }
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
   consume Z {
    consume Y {
     consume X {
      0
     }
    }
   }
  }
 }
}

Applying space time transformation...
Load matrix A_im that starts at (0, 0), and with extents (8, 32)
Load matrix B_im that starts at (0, 0), and with extents (8, 8)
Lowering after applying space time transformation:
gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
    realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
     realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       for (X.s0.k, 0, (A.extent.0/8)) {
        for (X.s0.kk, 0, 1) {
         for (X.s0.iii, 0, 32) {
          vectorized (X.s0.jjj, 0, 8) {
           for (X.s0.kkk, 0, 8) {
            let X.s0.kkk = X.s0.kkk
            let X.s0.jjj = X.s0.jjj
            let X.s0.iii = X.s0.iii
            X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
            Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)))
            Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (select((((X.s0.kkk == 0) && (X.s0.kk == 0)) && (X.s0.k == 0)), 0.000000f, select((X.s0.kkk == 0), select((X.s0.kk == 0), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0))) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
            if ((((X.s0.kkk == 7) && (X.s0.kk == 0)) && (X.s0.k == ((A.extent.0/8) + -1)))) {
             Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}


Fixing calls' args that correspond to loops marked as removed ...
Lowering after fixing calls' args that correspond to loops marked as removed:
gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
    realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
     realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       for (X.s0.k, 0, (A.extent.0/8)) {
        for (X.s0.kk, 0, 1) {
         for (X.s0.iii, 0, 32) {
          vectorized (X.s0.jjj, 0, 8) {
           for (X.s0.kkk, 0, 8) {
            let X.s0.kkk = X.s0.kkk
            let X.s0.jjj = X.s0.jjj
            let X.s0.iii = X.s0.iii
            X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
            Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)))
            Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (select((((X.s0.kkk == 0) && (X.s0.kk == 0)) && (X.s0.k == 0)), 0.000000f, select((X.s0.kkk == 0), select((X.s0.kk == 0), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0))) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
            if ((((X.s0.kkk == 7) && (X.s0.kk == 0)) && (X.s0.k == ((A.extent.0/8) + -1)))) {
             Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}


Skipping injecting memoization...
Injecting tracing...
Lowering after injecting tracing:
gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
    realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
     realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       for (X.s0.k, 0, (A.extent.0/8)) {
        for (X.s0.kk, 0, 1) {
         for (X.s0.iii, 0, 32) {
          vectorized (X.s0.jjj, 0, 8) {
           for (X.s0.kkk, 0, 8) {
            let X.s0.kkk = X.s0.kkk
            let X.s0.jjj = X.s0.jjj
            let X.s0.iii = X.s0.iii
            X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
            Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)))
            Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (select((((X.s0.kkk == 0) && (X.s0.kk == 0)) && (X.s0.k == 0)), 0.000000f, select((X.s0.kkk == 0), select((X.s0.kk == 0), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0))) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
            if ((((X.s0.kkk == 7) && (X.s0.kk == 0)) && (X.s0.k == ((A.extent.0/8) + -1)))) {
             Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}

Adding checks for recursice calls
Adding checks for parameters
Lowering after injecting parameter checks:
gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
    realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
     realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       for (X.s0.k, 0, (A.extent.0/8)) {
        for (X.s0.kk, 0, 1) {
         for (X.s0.iii, 0, 32) {
          vectorized (X.s0.jjj, 0, 8) {
           for (X.s0.kkk, 0, 8) {
            let X.s0.kkk = X.s0.kkk
            let X.s0.jjj = X.s0.jjj
            let X.s0.iii = X.s0.iii
            X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
            Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)))
            Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (select((((X.s0.kkk == 0) && (X.s0.kk == 0)) && (X.s0.k == 0)), 0.000000f, select((X.s0.kkk == 0), select((X.s0.kk == 0), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0))) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
            if ((((X.s0.kkk == 7) && (X.s0.kk == 0)) && (X.s0.k == ((A.extent.0/8) + -1)))) {
             Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}

Computing bounds of each function's value
Bounds on value 0 for func A_im are: ((void *))neg_inf, ((void *))pos_inf
Bounds on value 0 for func B_im are: ((void *))neg_inf, ((void *))pos_inf
Bounds on value 0 for func X are: ((void *))neg_inf, ((void *))pos_inf
Bounds on value 0 for func Y are: ((void *))neg_inf, ((void *))pos_inf
Bounds on value 0 for func Z are: ((void *))neg_inf, ((void *))pos_inf
Bounds on value 0 for func Out are: ((void *))neg_inf, ((void *))pos_inf
Adding checks for images
Injecting constraints for A.0
Injecting constraints for A.1
Injecting constraints for B.0
Injecting constraints for B.1
Injecting constraints for Out.0
Injecting constraints for Out.1
Injecting constraints for Out.2
Injecting constraints for Out.3
Injecting constraints for Out.4
Injecting constraints for Out.5
Lowering after injecting image checks:
let A.extent.0.required = A.extent.0
let A.min.0.required = A.min.0
let A.stride.0.required = 1
let A.extent.1.required = A.extent.1
let A.min.1.required = A.min.1
let A.stride.1.required = (A.stride.0.required*A.extent.0.required)
let B.extent.0.required = B.extent.0
let B.min.0.required = B.min.0
let B.stride.0.required = 1
let B.extent.1.required = B.extent.1
let B.min.1.required = B.min.1
let B.stride.1.required = (B.stride.0.required*B.extent.0.required)
let Out.extent.0.required = ((7 + 1) - 0)
let Out.min.0.required = 0
let Out.stride.0.required = 1
let Out.extent.1.required = ((31 + 1) - 0)
let Out.min.1.required = 0
let Out.stride.1.required = (Out.stride.0.required*Out.extent.0.required)
let Out.extent.2.required = ((((8 + 0) - 1) + 1) - 0)
let Out.min.2.required = 0
let Out.stride.2.required = (Out.stride.1.required*Out.extent.1.required)
let Out.extent.3.required = ((((2 + 0) - 1) + 1) - 0)
let Out.min.3.required = 0
let Out.stride.3.required = (Out.stride.2.required*Out.extent.2.required)
let Out.extent.4.required = (((((B.extent.0/64) + 0) - 1) + 1) - 0)
let Out.min.4.required = 0
let Out.stride.4.required = (Out.stride.3.required*Out.extent.3.required)
let Out.extent.5.required = (((((A.extent.1/64) + 0) - 1) + 1) - 0)
let Out.min.5.required = 0
let Out.stride.5.required = (Out.stride.4.required*Out.extent.4.required)
let A.stride.0.constrained = 1
let B.stride.0.constrained = 1
let Out.stride.0.constrained = 1
let A.stride.0.proposed = 1
let A.min.0.proposed = A.min.0.required
let A.extent.0.proposed = A.extent.0.required
let A.stride.1.proposed = A.stride.1.required
let A.min.1.proposed = A.min.1.required
let A.extent.1.proposed = A.extent.1.required
let B.stride.0.proposed = 1
let B.min.0.proposed = B.min.0.required
let B.extent.0.proposed = B.extent.0.required
let B.stride.1.proposed = B.stride.1.required
let B.min.1.proposed = B.min.1.required
let B.extent.1.proposed = B.extent.1.required
let Out.stride.0.proposed = 1
let Out.min.0.proposed = Out.min.0.required
let Out.extent.0.proposed = Out.extent.0.required
let Out.stride.1.proposed = Out.stride.1.required
let Out.min.1.proposed = Out.min.1.required
let Out.extent.1.proposed = Out.extent.1.required
let Out.stride.2.proposed = Out.stride.2.required
let Out.min.2.proposed = Out.min.2.required
let Out.extent.2.proposed = Out.extent.2.required
let Out.stride.3.proposed = Out.stride.3.required
let Out.min.3.proposed = Out.min.3.required
let Out.extent.3.proposed = Out.extent.3.required
let Out.stride.4.proposed = Out.stride.4.required
let Out.min.4.proposed = Out.min.4.required
let Out.extent.4.proposed = Out.extent.4.required
let Out.stride.5.proposed = Out.stride.5.required
let Out.min.5.proposed = Out.min.5.required
let Out.extent.5.proposed = Out.extent.5.required
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || ((A.min.0.proposed <= A.min.0.required) && (((A.min.0.proposed + A.extent.0.proposed) - 1) >= ((A.min.0.required + A.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer A", 0, A.min.0.proposed, ((A.min.0.proposed + A.extent.0.proposed) - 1), A.min.0.required, ((A.min.0.required + A.extent.0.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || ((A.min.1.proposed <= A.min.1.required) && (((A.min.1.proposed + A.extent.1.proposed) - 1) >= ((A.min.1.required + A.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer A", 1, A.min.1.proposed, ((A.min.1.proposed + A.extent.1.proposed) - 1), A.min.1.required, ((A.min.1.required + A.extent.1.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer) || ((B.min.0.proposed <= B.min.0.required) && (((B.min.0.proposed + B.extent.0.proposed) - 1) >= ((B.min.0.required + B.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer B", 0, B.min.0.proposed, ((B.min.0.proposed + B.extent.0.proposed) - 1), B.min.0.required, ((B.min.0.required + B.extent.0.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer) || ((B.min.1.proposed <= B.min.1.required) && (((B.min.1.proposed + B.extent.1.proposed) - 1) >= ((B.min.1.required + B.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer B", 1, B.min.1.proposed, ((B.min.1.proposed + B.extent.1.proposed) - 1), B.min.1.required, ((B.min.1.required + B.extent.1.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.0.proposed <= Out.min.0.required) && (((Out.min.0.proposed + Out.extent.0.proposed) - 1) >= ((Out.min.0.required + Out.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 0, Out.min.0.proposed, ((Out.min.0.proposed + Out.extent.0.proposed) - 1), Out.min.0.required, ((Out.min.0.required + Out.extent.0.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.1.proposed <= Out.min.1.required) && (((Out.min.1.proposed + Out.extent.1.proposed) - 1) >= ((Out.min.1.required + Out.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 1, Out.min.1.proposed, ((Out.min.1.proposed + Out.extent.1.proposed) - 1), Out.min.1.required, ((Out.min.1.required + Out.extent.1.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.2.proposed <= Out.min.2.required) && (((Out.min.2.proposed + Out.extent.2.proposed) - 1) >= ((Out.min.2.required + Out.extent.2.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 2, Out.min.2.proposed, ((Out.min.2.proposed + Out.extent.2.proposed) - 1), Out.min.2.required, ((Out.min.2.required + Out.extent.2.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.3.proposed <= Out.min.3.required) && (((Out.min.3.proposed + Out.extent.3.proposed) - 1) >= ((Out.min.3.required + Out.extent.3.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 3, Out.min.3.proposed, ((Out.min.3.proposed + Out.extent.3.proposed) - 1), Out.min.3.required, ((Out.min.3.required + Out.extent.3.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.4.proposed <= Out.min.4.required) && (((Out.min.4.proposed + Out.extent.4.proposed) - 1) >= ((Out.min.4.required + Out.extent.4.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 4, Out.min.4.proposed, ((Out.min.4.proposed + Out.extent.4.proposed) - 1), Out.min.4.required, ((Out.min.4.required + Out.extent.4.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.5.proposed <= Out.min.5.required) && (((Out.min.5.proposed + Out.extent.5.proposed) - 1) >= ((Out.min.5.required + Out.extent.5.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 5, Out.min.5.proposed, ((Out.min.5.proposed + Out.extent.5.proposed) - 1), Out.min.5.required, ((Out.min.5.required + Out.extent.5.required) - 1)))
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0.proposed, A.extent.0.proposed, A.stride.0.proposed, 0, A.min.1.proposed, A.extent.1.proposed, A.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0.proposed, B.extent.0.proposed, B.stride.0.proposed, 0, B.min.1.proposed, B.extent.1.proposed, B.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(Out.min.0.proposed, Out.extent.0.proposed, Out.stride.0.proposed, 0, Out.min.1.proposed, Out.extent.1.proposed, Out.stride.1.proposed, 0, Out.min.2.proposed, Out.extent.2.proposed, Out.stride.2.proposed, 0, Out.min.3.proposed, Out.extent.3.proposed, Out.stride.3.proposed, 0, Out.min.4.proposed, Out.extent.4.proposed, Out.stride.4.proposed, 0, Out.min.5.proposed, Out.extent.5.proposed, Out.stride.5.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 assert(((A.min.0 <= A.min.0.required) && (((A.min.0 + A.extent.0) - 1) >= ((A.min.0.required + A.extent.0.required) - 1))), halide_error_access_out_of_bounds("Input buffer A", 0, A.min.0.required, ((A.min.0.required + A.extent.0.required) - 1), A.min.0, ((A.min.0 + A.extent.0) - 1)))
 assert((A.extent.0 >= 0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 assert(((A.min.1 <= A.min.1.required) && (((A.min.1 + A.extent.1) - 1) >= ((A.min.1.required + A.extent.1.required) - 1))), halide_error_access_out_of_bounds("Input buffer A", 1, A.min.1.required, ((A.min.1.required + A.extent.1.required) - 1), A.min.1, ((A.min.1 + A.extent.1) - 1)))
 assert((A.extent.1 >= 0), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 assert(((B.min.0 <= B.min.0.required) && (((B.min.0 + B.extent.0) - 1) >= ((B.min.0.required + B.extent.0.required) - 1))), halide_error_access_out_of_bounds("Input buffer B", 0, B.min.0.required, ((B.min.0.required + B.extent.0.required) - 1), B.min.0, ((B.min.0 + B.extent.0) - 1)))
 assert((B.extent.0 >= 0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 assert(((B.min.1 <= B.min.1.required) && (((B.min.1 + B.extent.1) - 1) >= ((B.min.1.required + B.extent.1.required) - 1))), halide_error_access_out_of_bounds("Input buffer B", 1, B.min.1.required, ((B.min.1.required + B.extent.1.required) - 1), B.min.1, ((B.min.1 + B.extent.1) - 1)))
 assert((B.extent.1 >= 0), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= Out.min.0.required) && (((Out.min.0 + Out.extent.0) - 1) >= ((Out.min.0.required + Out.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 0, Out.min.0.required, ((Out.min.0.required + Out.extent.0.required) - 1), Out.min.0, ((Out.min.0 + Out.extent.0) - 1)))
 assert((Out.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= Out.min.1.required) && (((Out.min.1 + Out.extent.1) - 1) >= ((Out.min.1.required + Out.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 1, Out.min.1.required, ((Out.min.1.required + Out.extent.1.required) - 1), Out.min.1, ((Out.min.1 + Out.extent.1) - 1)))
 assert((Out.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= Out.min.2.required) && (((Out.min.2 + Out.extent.2) - 1) >= ((Out.min.2.required + Out.extent.2.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 2, Out.min.2.required, ((Out.min.2.required + Out.extent.2.required) - 1), Out.min.2, ((Out.min.2 + Out.extent.2) - 1)))
 assert((Out.extent.2 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= Out.min.3.required) && (((Out.min.3 + Out.extent.3) - 1) >= ((Out.min.3.required + Out.extent.3.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 3, Out.min.3.required, ((Out.min.3.required + Out.extent.3.required) - 1), Out.min.3, ((Out.min.3 + Out.extent.3) - 1)))
 assert((Out.extent.3 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= Out.min.4.required) && (((Out.min.4 + Out.extent.4) - 1) >= ((Out.min.4.required + Out.extent.4.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 4, Out.min.4.required, ((Out.min.4.required + Out.extent.4.required) - 1), Out.min.4, ((Out.min.4 + Out.extent.4) - 1)))
 assert((Out.extent.4 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= Out.min.5.required) && (((Out.min.5 + Out.extent.5) - 1) >= ((Out.min.5.required + Out.extent.5.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 5, Out.min.5.required, ((Out.min.5.required + Out.extent.5.required) - 1), Out.min.5, ((Out.min.5 + Out.extent.5) - 1)))
 assert((Out.extent.5 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == A.stride.0.constrained), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", A.stride.0.constrained))
 assert((B.stride.0 == B.stride.0.constrained), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", B.stride.0.constrained))
 assert((Out.stride.0 == Out.stride.0.constrained), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", Out.stride.0.constrained))
 let A.total_extent.0 = int64(A.extent.0)
 let A.total_extent.1 = (int64(A.extent.1)*A.total_extent.0)
 let B.total_extent.0 = int64(B.extent.0)
 let B.total_extent.1 = (int64(B.extent.1)*B.total_extent.0)
 let Out.total_extent.0 = int64(Out.extent.0)
 let Out.total_extent.1 = (int64(Out.extent.1)*Out.total_extent.0)
 let Out.total_extent.2 = (int64(Out.extent.2)*Out.total_extent.1)
 let Out.total_extent.3 = (int64(Out.extent.3)*Out.total_extent.2)
 let Out.total_extent.4 = (int64(Out.extent.4)*Out.total_extent.3)
 let Out.total_extent.5 = (int64(Out.extent.5)*Out.total_extent.4)
 assert(((uint64)abs((int64(A.extent.0)*int64(A.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.0)*int64(A.stride.0.constrained))), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(B.extent.0)*int64(B.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.0)*int64(B.stride.0.constrained))), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.0)*int64(Out.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.0)*int64(Out.stride.0.constrained))), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.kk, 0, 1) {
          for (X.s0.iii, 0, 32) {
           vectorized (X.s0.jjj, 0, 8) {
            for (X.s0.kkk, 0, 8) {
             let X.s0.kkk = X.s0.kkk
             let X.s0.jjj = X.s0.jjj
             let X.s0.iii = X.s0.iii
             X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
             Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)))
             Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (select((((X.s0.kkk == 0) && (X.s0.kk == 0)) && (X.s0.k == 0)), 0.000000f, select((X.s0.kkk == 0), select((X.s0.kk == 0), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0))) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
             if ((((X.s0.kkk == 7) && (X.s0.kk == 0)) && (X.s0.k == ((A.extent.0/8) + -1)))) {
              Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}

Performing computation bounds inference...
Lowering after computation bounds inference:
let A.extent.0.required = A.extent.0
let A.min.0.required = A.min.0
let A.stride.0.required = 1
let A.extent.1.required = A.extent.1
let A.min.1.required = A.min.1
let A.stride.1.required = (A.stride.0.required*A.extent.0.required)
let B.extent.0.required = B.extent.0
let B.min.0.required = B.min.0
let B.stride.0.required = 1
let B.extent.1.required = B.extent.1
let B.min.1.required = B.min.1
let B.stride.1.required = (B.stride.0.required*B.extent.0.required)
let Out.extent.0.required = ((7 + 1) - 0)
let Out.min.0.required = 0
let Out.stride.0.required = 1
let Out.extent.1.required = ((31 + 1) - 0)
let Out.min.1.required = 0
let Out.stride.1.required = (Out.stride.0.required*Out.extent.0.required)
let Out.extent.2.required = ((((8 + 0) - 1) + 1) - 0)
let Out.min.2.required = 0
let Out.stride.2.required = (Out.stride.1.required*Out.extent.1.required)
let Out.extent.3.required = ((((2 + 0) - 1) + 1) - 0)
let Out.min.3.required = 0
let Out.stride.3.required = (Out.stride.2.required*Out.extent.2.required)
let Out.extent.4.required = (((((B.extent.0/64) + 0) - 1) + 1) - 0)
let Out.min.4.required = 0
let Out.stride.4.required = (Out.stride.3.required*Out.extent.3.required)
let Out.extent.5.required = (((((A.extent.1/64) + 0) - 1) + 1) - 0)
let Out.min.5.required = 0
let Out.stride.5.required = (Out.stride.4.required*Out.extent.4.required)
let A.stride.0.constrained = 1
let B.stride.0.constrained = 1
let Out.stride.0.constrained = 1
let A.stride.0.proposed = 1
let A.min.0.proposed = A.min.0.required
let A.extent.0.proposed = A.extent.0.required
let A.stride.1.proposed = A.stride.1.required
let A.min.1.proposed = A.min.1.required
let A.extent.1.proposed = A.extent.1.required
let B.stride.0.proposed = 1
let B.min.0.proposed = B.min.0.required
let B.extent.0.proposed = B.extent.0.required
let B.stride.1.proposed = B.stride.1.required
let B.min.1.proposed = B.min.1.required
let B.extent.1.proposed = B.extent.1.required
let Out.stride.0.proposed = 1
let Out.min.0.proposed = Out.min.0.required
let Out.extent.0.proposed = Out.extent.0.required
let Out.stride.1.proposed = Out.stride.1.required
let Out.min.1.proposed = Out.min.1.required
let Out.extent.1.proposed = Out.extent.1.required
let Out.stride.2.proposed = Out.stride.2.required
let Out.min.2.proposed = Out.min.2.required
let Out.extent.2.proposed = Out.extent.2.required
let Out.stride.3.proposed = Out.stride.3.required
let Out.min.3.proposed = Out.min.3.required
let Out.extent.3.proposed = Out.extent.3.required
let Out.stride.4.proposed = Out.stride.4.required
let Out.min.4.proposed = Out.min.4.required
let Out.extent.4.proposed = Out.extent.4.required
let Out.stride.5.proposed = Out.stride.5.required
let Out.min.5.proposed = Out.min.5.required
let Out.extent.5.proposed = Out.extent.5.required
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || ((A.min.0.proposed <= A.min.0.required) && (((A.min.0.proposed + A.extent.0.proposed) - 1) >= ((A.min.0.required + A.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer A", 0, A.min.0.proposed, ((A.min.0.proposed + A.extent.0.proposed) - 1), A.min.0.required, ((A.min.0.required + A.extent.0.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || ((A.min.1.proposed <= A.min.1.required) && (((A.min.1.proposed + A.extent.1.proposed) - 1) >= ((A.min.1.required + A.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer A", 1, A.min.1.proposed, ((A.min.1.proposed + A.extent.1.proposed) - 1), A.min.1.required, ((A.min.1.required + A.extent.1.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer) || ((B.min.0.proposed <= B.min.0.required) && (((B.min.0.proposed + B.extent.0.proposed) - 1) >= ((B.min.0.required + B.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer B", 0, B.min.0.proposed, ((B.min.0.proposed + B.extent.0.proposed) - 1), B.min.0.required, ((B.min.0.required + B.extent.0.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer) || ((B.min.1.proposed <= B.min.1.required) && (((B.min.1.proposed + B.extent.1.proposed) - 1) >= ((B.min.1.required + B.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer B", 1, B.min.1.proposed, ((B.min.1.proposed + B.extent.1.proposed) - 1), B.min.1.required, ((B.min.1.required + B.extent.1.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.0.proposed <= Out.min.0.required) && (((Out.min.0.proposed + Out.extent.0.proposed) - 1) >= ((Out.min.0.required + Out.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 0, Out.min.0.proposed, ((Out.min.0.proposed + Out.extent.0.proposed) - 1), Out.min.0.required, ((Out.min.0.required + Out.extent.0.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.1.proposed <= Out.min.1.required) && (((Out.min.1.proposed + Out.extent.1.proposed) - 1) >= ((Out.min.1.required + Out.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 1, Out.min.1.proposed, ((Out.min.1.proposed + Out.extent.1.proposed) - 1), Out.min.1.required, ((Out.min.1.required + Out.extent.1.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.2.proposed <= Out.min.2.required) && (((Out.min.2.proposed + Out.extent.2.proposed) - 1) >= ((Out.min.2.required + Out.extent.2.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 2, Out.min.2.proposed, ((Out.min.2.proposed + Out.extent.2.proposed) - 1), Out.min.2.required, ((Out.min.2.required + Out.extent.2.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.3.proposed <= Out.min.3.required) && (((Out.min.3.proposed + Out.extent.3.proposed) - 1) >= ((Out.min.3.required + Out.extent.3.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 3, Out.min.3.proposed, ((Out.min.3.proposed + Out.extent.3.proposed) - 1), Out.min.3.required, ((Out.min.3.required + Out.extent.3.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.4.proposed <= Out.min.4.required) && (((Out.min.4.proposed + Out.extent.4.proposed) - 1) >= ((Out.min.4.required + Out.extent.4.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 4, Out.min.4.proposed, ((Out.min.4.proposed + Out.extent.4.proposed) - 1), Out.min.4.required, ((Out.min.4.required + Out.extent.4.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.5.proposed <= Out.min.5.required) && (((Out.min.5.proposed + Out.extent.5.proposed) - 1) >= ((Out.min.5.required + Out.extent.5.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 5, Out.min.5.proposed, ((Out.min.5.proposed + Out.extent.5.proposed) - 1), Out.min.5.required, ((Out.min.5.required + Out.extent.5.required) - 1)))
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0.proposed, A.extent.0.proposed, A.stride.0.proposed, 0, A.min.1.proposed, A.extent.1.proposed, A.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0.proposed, B.extent.0.proposed, B.stride.0.proposed, 0, B.min.1.proposed, B.extent.1.proposed, B.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(Out.min.0.proposed, Out.extent.0.proposed, Out.stride.0.proposed, 0, Out.min.1.proposed, Out.extent.1.proposed, Out.stride.1.proposed, 0, Out.min.2.proposed, Out.extent.2.proposed, Out.stride.2.proposed, 0, Out.min.3.proposed, Out.extent.3.proposed, Out.stride.3.proposed, 0, Out.min.4.proposed, Out.extent.4.proposed, Out.stride.4.proposed, 0, Out.min.5.proposed, Out.extent.5.proposed, Out.stride.5.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 assert(((A.min.0 <= A.min.0.required) && (((A.min.0 + A.extent.0) - 1) >= ((A.min.0.required + A.extent.0.required) - 1))), halide_error_access_out_of_bounds("Input buffer A", 0, A.min.0.required, ((A.min.0.required + A.extent.0.required) - 1), A.min.0, ((A.min.0 + A.extent.0) - 1)))
 assert((A.extent.0 >= 0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 assert(((A.min.1 <= A.min.1.required) && (((A.min.1 + A.extent.1) - 1) >= ((A.min.1.required + A.extent.1.required) - 1))), halide_error_access_out_of_bounds("Input buffer A", 1, A.min.1.required, ((A.min.1.required + A.extent.1.required) - 1), A.min.1, ((A.min.1 + A.extent.1) - 1)))
 assert((A.extent.1 >= 0), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 assert(((B.min.0 <= B.min.0.required) && (((B.min.0 + B.extent.0) - 1) >= ((B.min.0.required + B.extent.0.required) - 1))), halide_error_access_out_of_bounds("Input buffer B", 0, B.min.0.required, ((B.min.0.required + B.extent.0.required) - 1), B.min.0, ((B.min.0 + B.extent.0) - 1)))
 assert((B.extent.0 >= 0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 assert(((B.min.1 <= B.min.1.required) && (((B.min.1 + B.extent.1) - 1) >= ((B.min.1.required + B.extent.1.required) - 1))), halide_error_access_out_of_bounds("Input buffer B", 1, B.min.1.required, ((B.min.1.required + B.extent.1.required) - 1), B.min.1, ((B.min.1 + B.extent.1) - 1)))
 assert((B.extent.1 >= 0), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= Out.min.0.required) && (((Out.min.0 + Out.extent.0) - 1) >= ((Out.min.0.required + Out.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 0, Out.min.0.required, ((Out.min.0.required + Out.extent.0.required) - 1), Out.min.0, ((Out.min.0 + Out.extent.0) - 1)))
 assert((Out.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= Out.min.1.required) && (((Out.min.1 + Out.extent.1) - 1) >= ((Out.min.1.required + Out.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 1, Out.min.1.required, ((Out.min.1.required + Out.extent.1.required) - 1), Out.min.1, ((Out.min.1 + Out.extent.1) - 1)))
 assert((Out.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= Out.min.2.required) && (((Out.min.2 + Out.extent.2) - 1) >= ((Out.min.2.required + Out.extent.2.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 2, Out.min.2.required, ((Out.min.2.required + Out.extent.2.required) - 1), Out.min.2, ((Out.min.2 + Out.extent.2) - 1)))
 assert((Out.extent.2 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= Out.min.3.required) && (((Out.min.3 + Out.extent.3) - 1) >= ((Out.min.3.required + Out.extent.3.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 3, Out.min.3.required, ((Out.min.3.required + Out.extent.3.required) - 1), Out.min.3, ((Out.min.3 + Out.extent.3) - 1)))
 assert((Out.extent.3 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= Out.min.4.required) && (((Out.min.4 + Out.extent.4) - 1) >= ((Out.min.4.required + Out.extent.4.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 4, Out.min.4.required, ((Out.min.4.required + Out.extent.4.required) - 1), Out.min.4, ((Out.min.4 + Out.extent.4) - 1)))
 assert((Out.extent.4 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= Out.min.5.required) && (((Out.min.5 + Out.extent.5) - 1) >= ((Out.min.5.required + Out.extent.5.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 5, Out.min.5.required, ((Out.min.5.required + Out.extent.5.required) - 1), Out.min.5, ((Out.min.5 + Out.extent.5) - 1)))
 assert((Out.extent.5 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == A.stride.0.constrained), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", A.stride.0.constrained))
 assert((B.stride.0 == B.stride.0.constrained), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", B.stride.0.constrained))
 assert((Out.stride.0 == Out.stride.0.constrained), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", Out.stride.0.constrained))
 let A.total_extent.0 = int64(A.extent.0)
 let A.total_extent.1 = (int64(A.extent.1)*A.total_extent.0)
 let B.total_extent.0 = int64(B.extent.0)
 let B.total_extent.1 = (int64(B.extent.1)*B.total_extent.0)
 let Out.total_extent.0 = int64(Out.extent.0)
 let Out.total_extent.1 = (int64(Out.extent.1)*Out.total_extent.0)
 let Out.total_extent.2 = (int64(Out.extent.2)*Out.total_extent.1)
 let Out.total_extent.3 = (int64(Out.extent.3)*Out.total_extent.2)
 let Out.total_extent.4 = (int64(Out.extent.4)*Out.total_extent.3)
 let Out.total_extent.5 = (int64(Out.extent.5)*Out.total_extent.4)
 assert(((uint64)abs((int64(A.extent.0)*int64(A.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.0)*int64(A.stride.0.constrained))), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(B.extent.0)*int64(B.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.0)*int64(B.stride.0.constrained))), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.0)*int64(Out.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.0)*int64(Out.stride.0.constrained))), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.kk, 0, 1) {
          for (X.s0.iii, 0, 32) {
           vectorized (X.s0.jjj, 0, 8) {
            for (X.s0.kkk, 0, 8) {
             let X.s0.kkk = X.s0.kkk
             let X.s0.jjj = X.s0.jjj
             let X.s0.iii = X.s0.iii
             X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
             Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)))
             Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (select((((X.s0.kkk == 0) && (X.s0.kk == 0)) && (X.s0.k == 0)), 0.000000f, select((X.s0.kkk == 0), select((X.s0.kk == 0), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)), Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0))) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
             if ((((X.s0.kkk == 7) && (X.s0.kk == 0)) && (X.s0.k == ((A.extent.0/8) + -1)))) {
              Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}

Uniquifying variable names...
Lowering after uniquifying variable names:
let A.extent.0.required = A.extent.0
let A.min.0.required = A.min.0
let A.stride.0.required = 1
let A.extent.1.required = A.extent.1
let A.min.1.required = A.min.1
let A.stride.1.required = (A.stride.0.required*A.extent.0.required)
let B.extent.0.required = B.extent.0
let B.min.0.required = B.min.0
let B.stride.0.required = 1
let B.extent.1.required = B.extent.1
let B.min.1.required = B.min.1
let B.stride.1.required = (B.stride.0.required*B.extent.0.required)
let Out.extent.0.required = ((7 + 1) - 0)
let Out.min.0.required = 0
let Out.stride.0.required = 1
let Out.extent.1.required = ((31 + 1) - 0)
let Out.min.1.required = 0
let Out.stride.1.required = (Out.stride.0.required*Out.extent.0.required)
let Out.extent.2.required = ((((8 + 0) - 1) + 1) - 0)
let Out.min.2.required = 0
let Out.stride.2.required = (Out.stride.1.required*Out.extent.1.required)
let Out.extent.3.required = ((((2 + 0) - 1) + 1) - 0)
let Out.min.3.required = 0
let Out.stride.3.required = (Out.stride.2.required*Out.extent.2.required)
let Out.extent.4.required = (((((B.extent.0/64) + 0) - 1) + 1) - 0)
let Out.min.4.required = 0
let Out.stride.4.required = (Out.stride.3.required*Out.extent.3.required)
let Out.extent.5.required = (((((A.extent.1/64) + 0) - 1) + 1) - 0)
let Out.min.5.required = 0
let Out.stride.5.required = (Out.stride.4.required*Out.extent.4.required)
let A.stride.0.constrained = 1
let B.stride.0.constrained = 1
let Out.stride.0.constrained = 1
let A.stride.0.proposed = 1
let A.min.0.proposed = A.min.0.required
let A.extent.0.proposed = A.extent.0.required
let A.stride.1.proposed = A.stride.1.required
let A.min.1.proposed = A.min.1.required
let A.extent.1.proposed = A.extent.1.required
let B.stride.0.proposed = 1
let B.min.0.proposed = B.min.0.required
let B.extent.0.proposed = B.extent.0.required
let B.stride.1.proposed = B.stride.1.required
let B.min.1.proposed = B.min.1.required
let B.extent.1.proposed = B.extent.1.required
let Out.stride.0.proposed = 1
let Out.min.0.proposed = Out.min.0.required
let Out.extent.0.proposed = Out.extent.0.required
let Out.stride.1.proposed = Out.stride.1.required
let Out.min.1.proposed = Out.min.1.required
let Out.extent.1.proposed = Out.extent.1.required
let Out.stride.2.proposed = Out.stride.2.required
let Out.min.2.proposed = Out.min.2.required
let Out.extent.2.proposed = Out.extent.2.required
let Out.stride.3.proposed = Out.stride.3.required
let Out.min.3.proposed = Out.min.3.required
let Out.extent.3.proposed = Out.extent.3.required
let Out.stride.4.proposed = Out.stride.4.required
let Out.min.4.proposed = Out.min.4.required
let Out.extent.4.proposed = Out.extent.4.required
let Out.stride.5.proposed = Out.stride.5.required
let Out.min.5.proposed = Out.min.5.required
let Out.extent.5.proposed = Out.extent.5.required
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || ((A.min.0.proposed <= A.min.0.required) && (((A.min.0.proposed + A.extent.0.proposed) - 1) >= ((A.min.0.required + A.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer A", 0, A.min.0.proposed, ((A.min.0.proposed + A.extent.0.proposed) - 1), A.min.0.required, ((A.min.0.required + A.extent.0.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || ((A.min.1.proposed <= A.min.1.required) && (((A.min.1.proposed + A.extent.1.proposed) - 1) >= ((A.min.1.required + A.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer A", 1, A.min.1.proposed, ((A.min.1.proposed + A.extent.1.proposed) - 1), A.min.1.required, ((A.min.1.required + A.extent.1.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer) || ((B.min.0.proposed <= B.min.0.required) && (((B.min.0.proposed + B.extent.0.proposed) - 1) >= ((B.min.0.required + B.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer B", 0, B.min.0.proposed, ((B.min.0.proposed + B.extent.0.proposed) - 1), B.min.0.required, ((B.min.0.required + B.extent.0.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer) || ((B.min.1.proposed <= B.min.1.required) && (((B.min.1.proposed + B.extent.1.proposed) - 1) >= ((B.min.1.required + B.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer B", 1, B.min.1.proposed, ((B.min.1.proposed + B.extent.1.proposed) - 1), B.min.1.required, ((B.min.1.required + B.extent.1.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.0.proposed <= Out.min.0.required) && (((Out.min.0.proposed + Out.extent.0.proposed) - 1) >= ((Out.min.0.required + Out.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 0, Out.min.0.proposed, ((Out.min.0.proposed + Out.extent.0.proposed) - 1), Out.min.0.required, ((Out.min.0.required + Out.extent.0.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.1.proposed <= Out.min.1.required) && (((Out.min.1.proposed + Out.extent.1.proposed) - 1) >= ((Out.min.1.required + Out.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 1, Out.min.1.proposed, ((Out.min.1.proposed + Out.extent.1.proposed) - 1), Out.min.1.required, ((Out.min.1.required + Out.extent.1.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.2.proposed <= Out.min.2.required) && (((Out.min.2.proposed + Out.extent.2.proposed) - 1) >= ((Out.min.2.required + Out.extent.2.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 2, Out.min.2.proposed, ((Out.min.2.proposed + Out.extent.2.proposed) - 1), Out.min.2.required, ((Out.min.2.required + Out.extent.2.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.3.proposed <= Out.min.3.required) && (((Out.min.3.proposed + Out.extent.3.proposed) - 1) >= ((Out.min.3.required + Out.extent.3.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 3, Out.min.3.proposed, ((Out.min.3.proposed + Out.extent.3.proposed) - 1), Out.min.3.required, ((Out.min.3.required + Out.extent.3.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.4.proposed <= Out.min.4.required) && (((Out.min.4.proposed + Out.extent.4.proposed) - 1) >= ((Out.min.4.required + Out.extent.4.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 4, Out.min.4.proposed, ((Out.min.4.proposed + Out.extent.4.proposed) - 1), Out.min.4.required, ((Out.min.4.required + Out.extent.4.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.5.proposed <= Out.min.5.required) && (((Out.min.5.proposed + Out.extent.5.proposed) - 1) >= ((Out.min.5.required + Out.extent.5.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 5, Out.min.5.proposed, ((Out.min.5.proposed + Out.extent.5.proposed) - 1), Out.min.5.required, ((Out.min.5.required + Out.extent.5.required) - 1)))
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0.proposed, A.extent.0.proposed, A.stride.0.proposed, 0, A.min.1.proposed, A.extent.1.proposed, A.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0.proposed, B.extent.0.proposed, B.stride.0.proposed, 0, B.min.1.proposed, B.extent.1.proposed, B.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(Out.min.0.proposed, Out.extent.0.proposed, Out.stride.0.proposed, 0, Out.min.1.proposed, Out.extent.1.proposed, Out.stride.1.proposed, 0, Out.min.2.proposed, Out.extent.2.proposed, Out.stride.2.proposed, 0, Out.min.3.proposed, Out.extent.3.proposed, Out.stride.3.proposed, 0, Out.min.4.proposed, Out.extent.4.proposed, Out.stride.4.proposed, 0, Out.min.5.proposed, Out.extent.5.proposed, Out.stride.5.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 assert(((A.min.0 <= A.min.0.required) && (((A.min.0 + A.extent.0) - 1) >= ((A.min.0.required + A.extent.0.required) - 1))), halide_error_access_out_of_bounds("Input buffer A", 0, A.min.0.required, ((A.min.0.required + A.extent.0.required) - 1), A.min.0, ((A.min.0 + A.extent.0) - 1)))
 assert((A.extent.0 >= 0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 assert(((A.min.1 <= A.min.1.required) && (((A.min.1 + A.extent.1) - 1) >= ((A.min.1.required + A.extent.1.required) - 1))), halide_error_access_out_of_bounds("Input buffer A", 1, A.min.1.required, ((A.min.1.required + A.extent.1.required) - 1), A.min.1, ((A.min.1 + A.extent.1) - 1)))
 assert((A.extent.1 >= 0), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 assert(((B.min.0 <= B.min.0.required) && (((B.min.0 + B.extent.0) - 1) >= ((B.min.0.required + B.extent.0.required) - 1))), halide_error_access_out_of_bounds("Input buffer B", 0, B.min.0.required, ((B.min.0.required + B.extent.0.required) - 1), B.min.0, ((B.min.0 + B.extent.0) - 1)))
 assert((B.extent.0 >= 0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 assert(((B.min.1 <= B.min.1.required) && (((B.min.1 + B.extent.1) - 1) >= ((B.min.1.required + B.extent.1.required) - 1))), halide_error_access_out_of_bounds("Input buffer B", 1, B.min.1.required, ((B.min.1.required + B.extent.1.required) - 1), B.min.1, ((B.min.1 + B.extent.1) - 1)))
 assert((B.extent.1 >= 0), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= Out.min.0.required) && (((Out.min.0 + Out.extent.0) - 1) >= ((Out.min.0.required + Out.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 0, Out.min.0.required, ((Out.min.0.required + Out.extent.0.required) - 1), Out.min.0, ((Out.min.0 + Out.extent.0) - 1)))
 assert((Out.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= Out.min.1.required) && (((Out.min.1 + Out.extent.1) - 1) >= ((Out.min.1.required + Out.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 1, Out.min.1.required, ((Out.min.1.required + Out.extent.1.required) - 1), Out.min.1, ((Out.min.1 + Out.extent.1) - 1)))
 assert((Out.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= Out.min.2.required) && (((Out.min.2 + Out.extent.2) - 1) >= ((Out.min.2.required + Out.extent.2.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 2, Out.min.2.required, ((Out.min.2.required + Out.extent.2.required) - 1), Out.min.2, ((Out.min.2 + Out.extent.2) - 1)))
 assert((Out.extent.2 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= Out.min.3.required) && (((Out.min.3 + Out.extent.3) - 1) >= ((Out.min.3.required + Out.extent.3.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 3, Out.min.3.required, ((Out.min.3.required + Out.extent.3.required) - 1), Out.min.3, ((Out.min.3 + Out.extent.3) - 1)))
 assert((Out.extent.3 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= Out.min.4.required) && (((Out.min.4 + Out.extent.4) - 1) >= ((Out.min.4.required + Out.extent.4.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 4, Out.min.4.required, ((Out.min.4.required + Out.extent.4.required) - 1), Out.min.4, ((Out.min.4 + Out.extent.4) - 1)))
 assert((Out.extent.4 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= Out.min.5.required) && (((Out.min.5 + Out.extent.5) - 1) >= ((Out.min.5.required + Out.extent.5.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 5, Out.min.5.required, ((Out.min.5.required + Out.extent.5.required) - 1), Out.min.5, ((Out.min.5 + Out.extent.5) - 1)))
 assert((Out.extent.5 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == A.stride.0.constrained), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", A.stride.0.constrained))
 assert((B.stride.0 == B.stride.0.constrained), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", B.stride.0.constrained))
 assert((Out.stride.0 == Out.stride.0.constrained), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", Out.stride.0.constrained))
 let A.total_extent.0 = int64(A.extent.0)
 let A.total_extent.1 = (int64(A.extent.1)*A.total_extent.0)
 let B.total_extent.0 = int64(B.extent.0)
 let B.total_extent.1 = (int64(B.extent.1)*B.total_extent.0)
 let Out.total_extent.0 = int64(Out.extent.0)
 let Out.total_extent.1 = (int64(Out.extent.1)*Out.total_extent.0)
 let Out.total_extent.2 = (int64(Out.extent.2)*Out.total_extent.1)
 let Out.total_extent.3 = (int64(Out.extent.3)*Out.total_extent.2)
 let Out.total_extent.4 = (int64(Out.extent.4)*Out.total_extent.3)
 let Out.total_extent.5 = (int64(Out.extent.5)*Out.total_extent.4)
 assert(((uint64)abs((int64(A.extent.0)*int64(A.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.0)*int64(A.stride.0.constrained))), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(B.extent.0)*int64(B.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.0)*int64(B.stride.0.constrained))), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.0)*int64(Out.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.0)*int64(Out.stride.0.constrained))), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.kk, 0, 1) {
          for (X.s0.iii, 0, 32) {
           vectorized (X.s0.jjj, 0, 8) {
            for (X.s0.kkk, 0, 8) {
             let X.s0.kkk_1 = X.s0.kkk
             let X.s0.jjj_1 = X.s0.jjj
             let X.s0.iii_1 = X.s0.iii
             X(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk_1)), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii_1)))
             Y(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj_1)), ((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk_1)))
             Z(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0) = (select((((X.s0.kkk_1 == 0) && (X.s0.kk == 0)) && (X.s0.k == 0)), 0.000000f, select((X.s0.kkk_1 == 0), select((X.s0.kk == 0), Z(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0), Z(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0)), Z(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0))) + (X(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0)))
             if ((((X.s0.kkk_1 == 7) && (X.s0.kk == 0)) && (X.s0.k == ((A.extent.0/8) + -1)))) {
              Out(X.s0.jjj_1, X.s0.iii_1, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0)
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}


Partitioning loops to simplify boundary conditions...
Lowering after partitioning loops :
let A.extent.0.required = A.extent.0
let A.min.0.required = A.min.0
let A.stride.0.required = 1
let A.extent.1.required = A.extent.1
let A.min.1.required = A.min.1
let A.stride.1.required = (A.stride.0.required*A.extent.0.required)
let B.extent.0.required = B.extent.0
let B.min.0.required = B.min.0
let B.stride.0.required = 1
let B.extent.1.required = B.extent.1
let B.min.1.required = B.min.1
let B.stride.1.required = (B.stride.0.required*B.extent.0.required)
let Out.extent.0.required = ((7 + 1) - 0)
let Out.min.0.required = 0
let Out.stride.0.required = 1
let Out.extent.1.required = ((31 + 1) - 0)
let Out.min.1.required = 0
let Out.stride.1.required = (Out.stride.0.required*Out.extent.0.required)
let Out.extent.2.required = ((((8 + 0) - 1) + 1) - 0)
let Out.min.2.required = 0
let Out.stride.2.required = (Out.stride.1.required*Out.extent.1.required)
let Out.extent.3.required = ((((2 + 0) - 1) + 1) - 0)
let Out.min.3.required = 0
let Out.stride.3.required = (Out.stride.2.required*Out.extent.2.required)
let Out.extent.4.required = (((((B.extent.0/64) + 0) - 1) + 1) - 0)
let Out.min.4.required = 0
let Out.stride.4.required = (Out.stride.3.required*Out.extent.3.required)
let Out.extent.5.required = (((((A.extent.1/64) + 0) - 1) + 1) - 0)
let Out.min.5.required = 0
let Out.stride.5.required = (Out.stride.4.required*Out.extent.4.required)
let A.stride.0.constrained = 1
let B.stride.0.constrained = 1
let Out.stride.0.constrained = 1
let A.stride.0.proposed = 1
let A.min.0.proposed = A.min.0.required
let A.extent.0.proposed = A.extent.0.required
let A.stride.1.proposed = A.stride.1.required
let A.min.1.proposed = A.min.1.required
let A.extent.1.proposed = A.extent.1.required
let B.stride.0.proposed = 1
let B.min.0.proposed = B.min.0.required
let B.extent.0.proposed = B.extent.0.required
let B.stride.1.proposed = B.stride.1.required
let B.min.1.proposed = B.min.1.required
let B.extent.1.proposed = B.extent.1.required
let Out.stride.0.proposed = 1
let Out.min.0.proposed = Out.min.0.required
let Out.extent.0.proposed = Out.extent.0.required
let Out.stride.1.proposed = Out.stride.1.required
let Out.min.1.proposed = Out.min.1.required
let Out.extent.1.proposed = Out.extent.1.required
let Out.stride.2.proposed = Out.stride.2.required
let Out.min.2.proposed = Out.min.2.required
let Out.extent.2.proposed = Out.extent.2.required
let Out.stride.3.proposed = Out.stride.3.required
let Out.min.3.proposed = Out.min.3.required
let Out.extent.3.proposed = Out.extent.3.required
let Out.stride.4.proposed = Out.stride.4.required
let Out.min.4.proposed = Out.min.4.required
let Out.extent.4.proposed = Out.extent.4.required
let Out.stride.5.proposed = Out.stride.5.required
let Out.min.5.proposed = Out.min.5.required
let Out.extent.5.proposed = Out.extent.5.required
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || ((A.min.0.proposed <= A.min.0.required) && (((A.min.0.proposed + A.extent.0.proposed) - 1) >= ((A.min.0.required + A.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer A", 0, A.min.0.proposed, ((A.min.0.proposed + A.extent.0.proposed) - 1), A.min.0.required, ((A.min.0.required + A.extent.0.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || ((A.min.1.proposed <= A.min.1.required) && (((A.min.1.proposed + A.extent.1.proposed) - 1) >= ((A.min.1.required + A.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer A", 1, A.min.1.proposed, ((A.min.1.proposed + A.extent.1.proposed) - 1), A.min.1.required, ((A.min.1.required + A.extent.1.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer) || ((B.min.0.proposed <= B.min.0.required) && (((B.min.0.proposed + B.extent.0.proposed) - 1) >= ((B.min.0.required + B.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer B", 0, B.min.0.proposed, ((B.min.0.proposed + B.extent.0.proposed) - 1), B.min.0.required, ((B.min.0.required + B.extent.0.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer) || ((B.min.1.proposed <= B.min.1.required) && (((B.min.1.proposed + B.extent.1.proposed) - 1) >= ((B.min.1.required + B.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer B", 1, B.min.1.proposed, ((B.min.1.proposed + B.extent.1.proposed) - 1), B.min.1.required, ((B.min.1.required + B.extent.1.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.0.proposed <= Out.min.0.required) && (((Out.min.0.proposed + Out.extent.0.proposed) - 1) >= ((Out.min.0.required + Out.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 0, Out.min.0.proposed, ((Out.min.0.proposed + Out.extent.0.proposed) - 1), Out.min.0.required, ((Out.min.0.required + Out.extent.0.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.1.proposed <= Out.min.1.required) && (((Out.min.1.proposed + Out.extent.1.proposed) - 1) >= ((Out.min.1.required + Out.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 1, Out.min.1.proposed, ((Out.min.1.proposed + Out.extent.1.proposed) - 1), Out.min.1.required, ((Out.min.1.required + Out.extent.1.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.2.proposed <= Out.min.2.required) && (((Out.min.2.proposed + Out.extent.2.proposed) - 1) >= ((Out.min.2.required + Out.extent.2.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 2, Out.min.2.proposed, ((Out.min.2.proposed + Out.extent.2.proposed) - 1), Out.min.2.required, ((Out.min.2.required + Out.extent.2.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.3.proposed <= Out.min.3.required) && (((Out.min.3.proposed + Out.extent.3.proposed) - 1) >= ((Out.min.3.required + Out.extent.3.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 3, Out.min.3.proposed, ((Out.min.3.proposed + Out.extent.3.proposed) - 1), Out.min.3.required, ((Out.min.3.required + Out.extent.3.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.4.proposed <= Out.min.4.required) && (((Out.min.4.proposed + Out.extent.4.proposed) - 1) >= ((Out.min.4.required + Out.extent.4.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 4, Out.min.4.proposed, ((Out.min.4.proposed + Out.extent.4.proposed) - 1), Out.min.4.required, ((Out.min.4.required + Out.extent.4.required) - 1)))
assert((!(uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((Out.min.5.proposed <= Out.min.5.required) && (((Out.min.5.proposed + Out.extent.5.proposed) - 1) >= ((Out.min.5.required + Out.extent.5.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer Out", 5, Out.min.5.proposed, ((Out.min.5.proposed + Out.extent.5.proposed) - 1), Out.min.5.required, ((Out.min.5.required + Out.extent.5.required) - 1)))
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0.proposed, A.extent.0.proposed, A.stride.0.proposed, 0, A.min.1.proposed, A.extent.1.proposed, A.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0.proposed, B.extent.0.proposed, B.stride.0.proposed, 0, B.min.1.proposed, B.extent.1.proposed, B.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(Out.min.0.proposed, Out.extent.0.proposed, Out.stride.0.proposed, 0, Out.min.1.proposed, Out.extent.1.proposed, Out.stride.1.proposed, 0, Out.min.2.proposed, Out.extent.2.proposed, Out.stride.2.proposed, 0, Out.min.3.proposed, Out.extent.3.proposed, Out.stride.3.proposed, 0, Out.min.4.proposed, Out.extent.4.proposed, Out.stride.4.proposed, 0, Out.min.5.proposed, Out.extent.5.proposed, Out.stride.5.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 assert(((A.min.0 <= A.min.0.required) && (((A.min.0 + A.extent.0) - 1) >= ((A.min.0.required + A.extent.0.required) - 1))), halide_error_access_out_of_bounds("Input buffer A", 0, A.min.0.required, ((A.min.0.required + A.extent.0.required) - 1), A.min.0, ((A.min.0 + A.extent.0) - 1)))
 assert((A.extent.0 >= 0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 assert(((A.min.1 <= A.min.1.required) && (((A.min.1 + A.extent.1) - 1) >= ((A.min.1.required + A.extent.1.required) - 1))), halide_error_access_out_of_bounds("Input buffer A", 1, A.min.1.required, ((A.min.1.required + A.extent.1.required) - 1), A.min.1, ((A.min.1 + A.extent.1) - 1)))
 assert((A.extent.1 >= 0), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 assert(((B.min.0 <= B.min.0.required) && (((B.min.0 + B.extent.0) - 1) >= ((B.min.0.required + B.extent.0.required) - 1))), halide_error_access_out_of_bounds("Input buffer B", 0, B.min.0.required, ((B.min.0.required + B.extent.0.required) - 1), B.min.0, ((B.min.0 + B.extent.0) - 1)))
 assert((B.extent.0 >= 0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 assert(((B.min.1 <= B.min.1.required) && (((B.min.1 + B.extent.1) - 1) >= ((B.min.1.required + B.extent.1.required) - 1))), halide_error_access_out_of_bounds("Input buffer B", 1, B.min.1.required, ((B.min.1.required + B.extent.1.required) - 1), B.min.1, ((B.min.1 + B.extent.1) - 1)))
 assert((B.extent.1 >= 0), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= Out.min.0.required) && (((Out.min.0 + Out.extent.0) - 1) >= ((Out.min.0.required + Out.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 0, Out.min.0.required, ((Out.min.0.required + Out.extent.0.required) - 1), Out.min.0, ((Out.min.0 + Out.extent.0) - 1)))
 assert((Out.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= Out.min.1.required) && (((Out.min.1 + Out.extent.1) - 1) >= ((Out.min.1.required + Out.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 1, Out.min.1.required, ((Out.min.1.required + Out.extent.1.required) - 1), Out.min.1, ((Out.min.1 + Out.extent.1) - 1)))
 assert((Out.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= Out.min.2.required) && (((Out.min.2 + Out.extent.2) - 1) >= ((Out.min.2.required + Out.extent.2.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 2, Out.min.2.required, ((Out.min.2.required + Out.extent.2.required) - 1), Out.min.2, ((Out.min.2 + Out.extent.2) - 1)))
 assert((Out.extent.2 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= Out.min.3.required) && (((Out.min.3 + Out.extent.3) - 1) >= ((Out.min.3.required + Out.extent.3.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 3, Out.min.3.required, ((Out.min.3.required + Out.extent.3.required) - 1), Out.min.3, ((Out.min.3 + Out.extent.3) - 1)))
 assert((Out.extent.3 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= Out.min.4.required) && (((Out.min.4 + Out.extent.4) - 1) >= ((Out.min.4.required + Out.extent.4.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 4, Out.min.4.required, ((Out.min.4.required + Out.extent.4.required) - 1), Out.min.4, ((Out.min.4 + Out.extent.4) - 1)))
 assert((Out.extent.4 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= Out.min.5.required) && (((Out.min.5 + Out.extent.5) - 1) >= ((Out.min.5.required + Out.extent.5.required) - 1))), halide_error_access_out_of_bounds("Output buffer Out", 5, Out.min.5.required, ((Out.min.5.required + Out.extent.5.required) - 1), Out.min.5, ((Out.min.5 + Out.extent.5) - 1)))
 assert((Out.extent.5 >= 0), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == A.stride.0.constrained), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", A.stride.0.constrained))
 assert((B.stride.0 == B.stride.0.constrained), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", B.stride.0.constrained))
 assert((Out.stride.0 == Out.stride.0.constrained), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", Out.stride.0.constrained))
 let A.total_extent.0 = int64(A.extent.0)
 let A.total_extent.1 = (int64(A.extent.1)*A.total_extent.0)
 let B.total_extent.0 = int64(B.extent.0)
 let B.total_extent.1 = (int64(B.extent.1)*B.total_extent.0)
 let Out.total_extent.0 = int64(Out.extent.0)
 let Out.total_extent.1 = (int64(Out.extent.1)*Out.total_extent.0)
 let Out.total_extent.2 = (int64(Out.extent.2)*Out.total_extent.1)
 let Out.total_extent.3 = (int64(Out.extent.3)*Out.total_extent.2)
 let Out.total_extent.4 = (int64(Out.extent.4)*Out.total_extent.3)
 let Out.total_extent.5 = (int64(Out.extent.5)*Out.total_extent.4)
 assert(((uint64)abs((int64(A.extent.0)*int64(A.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.0)*int64(A.stride.0.constrained))), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(B.extent.0)*int64(B.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.0)*int64(B.stride.0.constrained))), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.0)*int64(Out.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.0)*int64(Out.stride.0.constrained))), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.kk, 0, 1) {
          for (X.s0.iii, 0, 32) {
           vectorized (X.s0.jjj, 0, 8) {
            for (X.s0.kkk, 0, 8) {
             let X.s0.kkk_1 = X.s0.kkk
             let X.s0.jjj_1 = X.s0.jjj
             let X.s0.iii_1 = X.s0.iii
             X(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk_1)), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii_1)))
             Y(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj_1)), ((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk_1)))
             Z(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0) = ((let t3 = select(((X.s0.kkk_1 == 0) && (X.s0.kk == 0)), Z(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0), Z(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0)) in select((((X.s0.kkk_1 == 0) && (X.s0.kk == 0)) && (X.s0.k == 0)), 0.000000f, t3)) + (X(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0)))
             if ((((X.s0.kkk_1 == 7) && (X.s0.kk == 0)) && (X.s0.k == ((A.extent.0/8) + -1)))) {
              Out(X.s0.jjj_1, X.s0.iii_1, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj_1, X.s0.iii_1, 0, 0, 0, 0, 0, 0, 0)
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}


Simplifying IfThenElse but keeping unit loops...
Lowering after simplifying IfThenElse but keeping unit loops:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 0
 assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 0
 assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 0
 assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 0
 assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
 assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
 assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
 assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
 assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
 assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
 assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
 assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
 assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
 let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
 let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
 let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
 let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
 let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
 let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
 let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
 assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.kk, 0, 1) {
          for (X.s0.iii, 0, 32) {
           vectorized (X.s0.jjj, 0, 8) {
            for (X.s0.kkk, 0, 8) {
             X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
             Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)))
             Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = ((let t3 = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) in select((((X.s0.kkk == 0) && (X.s0.kk == 0)) && (X.s0.k == 0)), 0.000000f, t3)) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
             if ((((X.s0.kkk == 7) && (X.s0.kk == 0)) && (X.s0.k == ((A.extent.0/8) + -1)))) {
              Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}


Removing extern loops...
Lowering after removing extern loops:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 0
 assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 0
 assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 0
 assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 0
 assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
 assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
 assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
 assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
 assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
 assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
 assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
 assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
 assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
 let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
 let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
 let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
 let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
 let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
 let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
 let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
 assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.kk, 0, 1) {
          for (X.s0.iii, 0, 32) {
           vectorized (X.s0.jjj, 0, 8) {
            for (X.s0.kkk, 0, 8) {
             X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
             Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)))
             Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = ((let t3 = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) in select((((X.s0.kkk == 0) && (X.s0.kk == 0)) && (X.s0.k == 0)), 0.000000f, t3)) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
             if ((((X.s0.kkk == 7) && (X.s0.kk == 0)) && (X.s0.k == ((A.extent.0/8) + -1)))) {
              Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}

Performing sliding window optimization...
Lowering after sliding window:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 0
 assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 0
 assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 0
 assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 0
 assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
 assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
 assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
 assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
 assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
 assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
 assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
 assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
 assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
 let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
 let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
 let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
 let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
 let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
 let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
 let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
 assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.kk, 0, 1) {
          for (X.s0.iii, 0, 32) {
           vectorized (X.s0.jjj, 0, 8) {
            for (X.s0.kkk, 0, 8) {
             X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
             Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)))
             Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = ((let t3 = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) in select((((X.s0.kkk == 0) && (X.s0.kk == 0)) && (X.s0.k == 0)), 0.000000f, t3)) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
             if ((((X.s0.kkk == 7) && (X.s0.kk == 0)) && (X.s0.k == ((A.extent.0/8) + -1)))) {
              Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}

Simplifying correlated differences...
Lowering after simplifying correlated differences:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 0
 assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 0
 assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 0
 assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 0
 assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
 assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
 assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
 assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
 assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
 assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
 assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
 assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
 assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
 let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
 let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
 let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
 let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
 let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
 let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
 let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
 assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.kk, 0, 1) {
          for (X.s0.iii, 0, 32) {
           vectorized (X.s0.jjj, 0, 8) {
            for (X.s0.kkk, 0, 8) {
             X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
             Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)))
             Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = ((let t3 = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) in select((((X.s0.kkk == 0) && (X.s0.kk == 0)) && (X.s0.k == 0)), 0.000000f, t3)) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
             if ((((X.s0.kkk == 7) && (X.s0.kk == 0)) && (X.s0.k == ((A.extent.0/8) + -1)))) {
              Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}

Performing allocation bounds inference...
Lowering after allocation bounds inference:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 0
 assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 0
 assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 0
 assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 0
 assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
 assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
 assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
 assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
 assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
 assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
 assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
 assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
 assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
 let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
 let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
 let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
 let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
 let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
 let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
 let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
 assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     let X.i.max_realized = ((A.extent.1/64) + -1)
     let X.i.min_realized = 0
     let X.i.extent_realized = (A.extent.1/64)
     let X.j.max_realized = ((B.extent.0/64) + -1)
     let X.j.min_realized = 0
     let X.j.extent_realized = (B.extent.0/64)
     let X.k.max_realized = ((A.extent.0/8) + -1)
     let X.k.min_realized = 0
     let X.k.extent_realized = (A.extent.0/8)
     let X.kk.max_realized = 0
     let X.kk.min_realized = 0
     let X.kk.extent_realized = 1
     let X.ii.max_realized = 1
     let X.ii.min_realized = 0
     let X.ii.extent_realized = 2
     let X.jj.max_realized = 7
     let X.jj.min_realized = 0
     let X.jj.extent_realized = 8
     let X.iii.max_realized = 31
     let X.iii.min_realized = 0
     let X.iii.extent_realized = 32
     let X.jjj.max_realized = 7
     let X.jjj.min_realized = 0
     let X.jjj.extent_realized = 8
     let X.kkk.max_realized = 7
     let X.kkk.min_realized = 0
     let X.kkk.extent_realized = 8
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      let Y.i.max_realized = ((A.extent.1/64) + -1)
      let Y.i.min_realized = 0
      let Y.i.extent_realized = (A.extent.1/64)
      let Y.j.max_realized = ((B.extent.0/64) + -1)
      let Y.j.min_realized = 0
      let Y.j.extent_realized = (B.extent.0/64)
      let Y.k.max_realized = ((A.extent.0/8) + -1)
      let Y.k.min_realized = 0
      let Y.k.extent_realized = (A.extent.0/8)
      let Y.kk.max_realized = 0
      let Y.kk.min_realized = 0
      let Y.kk.extent_realized = 1
      let Y.ii.max_realized = 1
      let Y.ii.min_realized = 0
      let Y.ii.extent_realized = 2
      let Y.jj.max_realized = 7
      let Y.jj.min_realized = 0
      let Y.jj.extent_realized = 8
      let Y.iii.max_realized = 31
      let Y.iii.min_realized = 0
      let Y.iii.extent_realized = 32
      let Y.jjj.max_realized = 7
      let Y.jjj.min_realized = 0
      let Y.jjj.extent_realized = 8
      let Y.kkk.max_realized = 7
      let Y.kkk.min_realized = 0
      let Y.kkk.extent_realized = 8
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       let Z.i.max_realized = ((A.extent.1/64) + -1)
       let Z.i.min_realized = 0
       let Z.i.extent_realized = (A.extent.1/64)
       let Z.j.max_realized = ((B.extent.0/64) + -1)
       let Z.j.min_realized = 0
       let Z.j.extent_realized = (B.extent.0/64)
       let Z.k.max_realized = ((A.extent.0/8) + -1)
       let Z.k.min_realized = 0
       let Z.k.extent_realized = (A.extent.0/8)
       let Z.kk.max_realized = 0
       let Z.kk.min_realized = 0
       let Z.kk.extent_realized = 1
       let Z.ii.max_realized = 1
       let Z.ii.min_realized = 0
       let Z.ii.extent_realized = 2
       let Z.jj.max_realized = 7
       let Z.jj.min_realized = 0
       let Z.jj.extent_realized = 8
       let Z.iii.max_realized = 31
       let Z.iii.min_realized = 0
       let Z.iii.extent_realized = 32
       let Z.jjj.max_realized = 7
       let Z.jjj.min_realized = 0
       let Z.jjj.extent_realized = 8
       let Z.kkk.max_realized = 7
       let Z.kkk.min_realized = 0
       let Z.kkk.extent_realized = 8
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.kk, 0, 1) {
          for (X.s0.iii, 0, 32) {
           vectorized (X.s0.jjj, 0, 8) {
            for (X.s0.kkk, 0, 8) {
             X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
             Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)))
             Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = ((let t3 = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) in select((((X.s0.kkk == 0) && (X.s0.kk == 0)) && (X.s0.k == 0)), 0.000000f, t3)) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
             if ((((X.s0.kkk == 7) && (X.s0.kk == 0)) && (X.s0.k == ((A.extent.0/8) + -1)))) {
              Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}

Removing code that depends on undef values...
Lowering after removing code that depends on undef values:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 0
 assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 0
 assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 0
 assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 0
 assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
 assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
 assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
 assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
 assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
 assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
 assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
 assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
 assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
 let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
 let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
 let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
 let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
 let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
 let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
 let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
 assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     let X.i.max_realized = ((A.extent.1/64) + -1)
     let X.i.min_realized = 0
     let X.i.extent_realized = (A.extent.1/64)
     let X.j.max_realized = ((B.extent.0/64) + -1)
     let X.j.min_realized = 0
     let X.j.extent_realized = (B.extent.0/64)
     let X.k.max_realized = ((A.extent.0/8) + -1)
     let X.k.min_realized = 0
     let X.k.extent_realized = (A.extent.0/8)
     let X.kk.max_realized = 0
     let X.kk.min_realized = 0
     let X.kk.extent_realized = 1
     let X.ii.max_realized = 1
     let X.ii.min_realized = 0
     let X.ii.extent_realized = 2
     let X.jj.max_realized = 7
     let X.jj.min_realized = 0
     let X.jj.extent_realized = 8
     let X.iii.max_realized = 31
     let X.iii.min_realized = 0
     let X.iii.extent_realized = 32
     let X.jjj.max_realized = 7
     let X.jjj.min_realized = 0
     let X.jjj.extent_realized = 8
     let X.kkk.max_realized = 7
     let X.kkk.min_realized = 0
     let X.kkk.extent_realized = 8
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      let Y.i.max_realized = ((A.extent.1/64) + -1)
      let Y.i.min_realized = 0
      let Y.i.extent_realized = (A.extent.1/64)
      let Y.j.max_realized = ((B.extent.0/64) + -1)
      let Y.j.min_realized = 0
      let Y.j.extent_realized = (B.extent.0/64)
      let Y.k.max_realized = ((A.extent.0/8) + -1)
      let Y.k.min_realized = 0
      let Y.k.extent_realized = (A.extent.0/8)
      let Y.kk.max_realized = 0
      let Y.kk.min_realized = 0
      let Y.kk.extent_realized = 1
      let Y.ii.max_realized = 1
      let Y.ii.min_realized = 0
      let Y.ii.extent_realized = 2
      let Y.jj.max_realized = 7
      let Y.jj.min_realized = 0
      let Y.jj.extent_realized = 8
      let Y.iii.max_realized = 31
      let Y.iii.min_realized = 0
      let Y.iii.extent_realized = 32
      let Y.jjj.max_realized = 7
      let Y.jjj.min_realized = 0
      let Y.jjj.extent_realized = 8
      let Y.kkk.max_realized = 7
      let Y.kkk.min_realized = 0
      let Y.kkk.extent_realized = 8
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       let Z.i.max_realized = ((A.extent.1/64) + -1)
       let Z.i.min_realized = 0
       let Z.i.extent_realized = (A.extent.1/64)
       let Z.j.max_realized = ((B.extent.0/64) + -1)
       let Z.j.min_realized = 0
       let Z.j.extent_realized = (B.extent.0/64)
       let Z.k.max_realized = ((A.extent.0/8) + -1)
       let Z.k.min_realized = 0
       let Z.k.extent_realized = (A.extent.0/8)
       let Z.kk.max_realized = 0
       let Z.kk.min_realized = 0
       let Z.kk.extent_realized = 1
       let Z.ii.max_realized = 1
       let Z.ii.min_realized = 0
       let Z.ii.extent_realized = 2
       let Z.jj.max_realized = 7
       let Z.jj.min_realized = 0
       let Z.jj.extent_realized = 8
       let Z.iii.max_realized = 31
       let Z.iii.min_realized = 0
       let Z.iii.extent_realized = 32
       let Z.jjj.max_realized = 7
       let Z.jjj.min_realized = 0
       let Z.jjj.extent_realized = 8
       let Z.kkk.max_realized = 7
       let Z.kkk.min_realized = 0
       let Z.kkk.extent_realized = 8
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.kk, 0, 1) {
          for (X.s0.iii, 0, 32) {
           vectorized (X.s0.jjj, 0, 8) {
            for (X.s0.kkk, 0, 8) {
             X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
             Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)))
             Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = ((let t3 = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) in select((((X.s0.kkk == 0) && (X.s0.kk == 0)) && (X.s0.k == 0)), 0.000000f, t3)) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
             if ((((X.s0.kkk == 7) && (X.s0.kk == 0)) && (X.s0.k == ((A.extent.0/8) + -1)))) {
              Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}


Placing device functions...
Lowering after placing device functions:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 0
 assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 0
 assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 0
 assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 0
 assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
 assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
 assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
 assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
 assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
 assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
 assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
 assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
 assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
 let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
 let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
 let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
 let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
 let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
 let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
 let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
 assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     let X.i.max_realized = ((A.extent.1/64) + -1)
     let X.i.min_realized = 0
     let X.i.extent_realized = (A.extent.1/64)
     let X.j.max_realized = ((B.extent.0/64) + -1)
     let X.j.min_realized = 0
     let X.j.extent_realized = (B.extent.0/64)
     let X.k.max_realized = ((A.extent.0/8) + -1)
     let X.k.min_realized = 0
     let X.k.extent_realized = (A.extent.0/8)
     let X.kk.max_realized = 0
     let X.kk.min_realized = 0
     let X.kk.extent_realized = 1
     let X.ii.max_realized = 1
     let X.ii.min_realized = 0
     let X.ii.extent_realized = 2
     let X.jj.max_realized = 7
     let X.jj.min_realized = 0
     let X.jj.extent_realized = 8
     let X.iii.max_realized = 31
     let X.iii.min_realized = 0
     let X.iii.extent_realized = 32
     let X.jjj.max_realized = 7
     let X.jjj.min_realized = 0
     let X.jjj.extent_realized = 8
     let X.kkk.max_realized = 7
     let X.kkk.min_realized = 0
     let X.kkk.extent_realized = 8
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      let Y.i.max_realized = ((A.extent.1/64) + -1)
      let Y.i.min_realized = 0
      let Y.i.extent_realized = (A.extent.1/64)
      let Y.j.max_realized = ((B.extent.0/64) + -1)
      let Y.j.min_realized = 0
      let Y.j.extent_realized = (B.extent.0/64)
      let Y.k.max_realized = ((A.extent.0/8) + -1)
      let Y.k.min_realized = 0
      let Y.k.extent_realized = (A.extent.0/8)
      let Y.kk.max_realized = 0
      let Y.kk.min_realized = 0
      let Y.kk.extent_realized = 1
      let Y.ii.max_realized = 1
      let Y.ii.min_realized = 0
      let Y.ii.extent_realized = 2
      let Y.jj.max_realized = 7
      let Y.jj.min_realized = 0
      let Y.jj.extent_realized = 8
      let Y.iii.max_realized = 31
      let Y.iii.min_realized = 0
      let Y.iii.extent_realized = 32
      let Y.jjj.max_realized = 7
      let Y.jjj.min_realized = 0
      let Y.jjj.extent_realized = 8
      let Y.kkk.max_realized = 7
      let Y.kkk.min_realized = 0
      let Y.kkk.extent_realized = 8
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       let Z.i.max_realized = ((A.extent.1/64) + -1)
       let Z.i.min_realized = 0
       let Z.i.extent_realized = (A.extent.1/64)
       let Z.j.max_realized = ((B.extent.0/64) + -1)
       let Z.j.min_realized = 0
       let Z.j.extent_realized = (B.extent.0/64)
       let Z.k.max_realized = ((A.extent.0/8) + -1)
       let Z.k.min_realized = 0
       let Z.k.extent_realized = (A.extent.0/8)
       let Z.kk.max_realized = 0
       let Z.kk.min_realized = 0
       let Z.kk.extent_realized = 1
       let Z.ii.max_realized = 1
       let Z.ii.min_realized = 0
       let Z.ii.extent_realized = 2
       let Z.jj.max_realized = 7
       let Z.jj.min_realized = 0
       let Z.jj.extent_realized = 8
       let Z.iii.max_realized = 31
       let Z.iii.min_realized = 0
       let Z.iii.extent_realized = 32
       let Z.jjj.max_realized = 7
       let Z.jjj.min_realized = 0
       let Z.jjj.extent_realized = 8
       let Z.kkk.max_realized = 7
       let Z.kkk.min_realized = 0
       let Z.kkk.extent_realized = 8
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.kk, 0, 1) {
          for (X.s0.iii, 0, 32) {
           vectorized (X.s0.jjj, 0, 8) {
            for (X.s0.kkk, 0, 8) {
             X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
             Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)))
             Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = ((let t3 = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) in select((((X.s0.kkk == 0) && (X.s0.kk == 0)) && (X.s0.k == 0)), 0.000000f, t3)) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
             if ((((X.s0.kkk == 7) && (X.s0.kk == 0)) && (X.s0.k == ((A.extent.0/8) + -1)))) {
              Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}


Replacing references with channels and shift registers...
Lowering after replacing references with channels and shift registers:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 0
 assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 0
 assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 0
 assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 0
 assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
 assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
 assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
 assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
 assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
 assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
 assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
 assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
 assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
 let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
 let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
 let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
 let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
 let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
 let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
 let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
 assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     let X.i.max_realized = ((A.extent.1/64) + -1)
     let X.i.min_realized = 0
     let X.i.extent_realized = (A.extent.1/64)
     let X.j.max_realized = ((B.extent.0/64) + -1)
     let X.j.min_realized = 0
     let X.j.extent_realized = (B.extent.0/64)
     let X.k.max_realized = ((A.extent.0/8) + -1)
     let X.k.min_realized = 0
     let X.k.extent_realized = (A.extent.0/8)
     let X.kk.max_realized = 0
     let X.kk.min_realized = 0
     let X.kk.extent_realized = 1
     let X.ii.max_realized = 1
     let X.ii.min_realized = 0
     let X.ii.extent_realized = 2
     let X.jj.max_realized = 7
     let X.jj.min_realized = 0
     let X.jj.extent_realized = 8
     let X.iii.max_realized = 31
     let X.iii.min_realized = 0
     let X.iii.extent_realized = 32
     let X.jjj.max_realized = 7
     let X.jjj.min_realized = 0
     let X.jjj.extent_realized = 8
     let X.kkk.max_realized = 7
     let X.kkk.min_realized = 0
     let X.kkk.extent_realized = 8
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      let Y.i.max_realized = ((A.extent.1/64) + -1)
      let Y.i.min_realized = 0
      let Y.i.extent_realized = (A.extent.1/64)
      let Y.j.max_realized = ((B.extent.0/64) + -1)
      let Y.j.min_realized = 0
      let Y.j.extent_realized = (B.extent.0/64)
      let Y.k.max_realized = ((A.extent.0/8) + -1)
      let Y.k.min_realized = 0
      let Y.k.extent_realized = (A.extent.0/8)
      let Y.kk.max_realized = 0
      let Y.kk.min_realized = 0
      let Y.kk.extent_realized = 1
      let Y.ii.max_realized = 1
      let Y.ii.min_realized = 0
      let Y.ii.extent_realized = 2
      let Y.jj.max_realized = 7
      let Y.jj.min_realized = 0
      let Y.jj.extent_realized = 8
      let Y.iii.max_realized = 31
      let Y.iii.min_realized = 0
      let Y.iii.extent_realized = 32
      let Y.jjj.max_realized = 7
      let Y.jjj.min_realized = 0
      let Y.jjj.extent_realized = 8
      let Y.kkk.max_realized = 7
      let Y.kkk.min_realized = 0
      let Y.kkk.extent_realized = 8
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       let Z.i.max_realized = ((A.extent.1/64) + -1)
       let Z.i.min_realized = 0
       let Z.i.extent_realized = (A.extent.1/64)
       let Z.j.max_realized = ((B.extent.0/64) + -1)
       let Z.j.min_realized = 0
       let Z.j.extent_realized = (B.extent.0/64)
       let Z.k.max_realized = ((A.extent.0/8) + -1)
       let Z.k.min_realized = 0
       let Z.k.extent_realized = (A.extent.0/8)
       let Z.kk.max_realized = 0
       let Z.kk.min_realized = 0
       let Z.kk.extent_realized = 1
       let Z.ii.max_realized = 1
       let Z.ii.min_realized = 0
       let Z.ii.extent_realized = 2
       let Z.jj.max_realized = 7
       let Z.jj.min_realized = 0
       let Z.jj.extent_realized = 8
       let Z.iii.max_realized = 31
       let Z.iii.min_realized = 0
       let Z.iii.extent_realized = 32
       let Z.jjj.max_realized = 7
       let Z.jjj.min_realized = 0
       let Z.jjj.extent_realized = 8
       let Z.kkk.max_realized = 7
       let Z.kkk.min_realized = 0
       let Z.kkk.extent_realized = 8
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.kk, 0, 1) {
          for (X.s0.iii, 0, 32) {
           vectorized (X.s0.jjj, 0, 8) {
            for (X.s0.kkk, 0, 8) {
             X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
             Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + ((X.s0.kk*8) + X.s0.kkk)))
             Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = ((let t3 = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) in select((((X.s0.kkk == 0) && (X.s0.kk == 0)) && (X.s0.k == 0)), 0.000000f, t3)) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
             if ((((X.s0.kkk == 7) && (X.s0.kk == 0)) && (X.s0.k == ((A.extent.0/8) + -1)))) {
              Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}


Simplifying IfThenElse without keeping unit loops...
Lowering after simplifying IfThenElse without keeping unit loops:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
 assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
 assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
 assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
 assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
 assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
 assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
 assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
 assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
 let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
 let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
 let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
 let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
 let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
 let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
 let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
 assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.iii, 0, 32) {
          vectorized (X.s0.jjj, 0, 8) {
           for (X.s0.kkk, 0, 8) {
            X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + X.s0.kkk), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
            Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + X.s0.kkk))
            Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = ((let t3 = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) in select(((X.s0.kkk == 0) && (X.s0.k == 0)), 0.000000f, t3)) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
            if (((X.s0.kkk == 7) && (X.s0.k == ((A.extent.0/8) + -1)))) {
             Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}


Performing storage folding optimization...
Lowering after storage folding:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
 assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
 assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
 assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
 assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
 assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
 assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
 assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
 assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
 let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
 let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
 let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
 let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
 let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
 let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
 let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
 assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.iii, 0, 32) {
          vectorized (X.s0.jjj, 0, 8) {
           for (X.s0.kkk, 0, 8) {
            X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + X.s0.kkk), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
            Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + X.s0.kkk))
            Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = ((let t3 = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) in select(((X.s0.kkk == 0) && (X.s0.k == 0)), 0.000000f, t3)) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
            if (((X.s0.kkk == 7) && (X.s0.k == ((A.extent.0/8) + -1)))) {
             Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}

Injecting debug_to_file calls...
Lowering after injecting debug_to_file calls:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
 assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
 assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
 assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
 assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
 assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
 assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
 assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
 assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
 let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
 let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
 let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
 let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
 let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
 let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
 let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
 assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.iii, 0, 32) {
          vectorized (X.s0.jjj, 0, 8) {
           for (X.s0.kkk, 0, 8) {
            X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + X.s0.kkk), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
            Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + X.s0.kkk))
            Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = ((let t3 = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) in select(((X.s0.kkk == 0) && (X.s0.k == 0)), 0.000000f, t3)) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
            if (((X.s0.kkk == 7) && (X.s0.k == ((A.extent.0/8) + -1)))) {
             Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}

Injecting prefetches...
Lowering after injecting prefetches:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
 assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
 assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
 assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
 assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
 assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
 assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
 assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
 assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
 let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
 let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
 let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
 let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
 let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
 let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
 let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
 assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.iii, 0, 32) {
          vectorized (X.s0.jjj, 0, 8) {
           for (X.s0.kkk, 0, 8) {
            X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + X.s0.kkk), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
            Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + X.s0.kkk))
            Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = ((let t3 = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) in select(((X.s0.kkk == 0) && (X.s0.k == 0)), 0.000000f, t3)) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
            if (((X.s0.kkk == 7) && (X.s0.k == ((A.extent.0/8) + -1)))) {
             Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}


Destructuring tuple-valued realizations...
Lowering after destructuring tuple-valued realizations:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
 assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
 assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
 assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
 assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
 assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
 assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
 assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
 assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
 let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
 let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
 let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
 let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
 let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
 let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
 let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
 assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj, 0, 8) {
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.iii, 0, 32) {
          vectorized (X.s0.jjj, 0, 8) {
           for (X.s0.kkk, 0, 8) {
            X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + X.s0.kkk), ((X.s0.i*64) + ((X.s0.ii*32) + X.s0.iii)))
            Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j*64) + ((X.s0.jj*8) + X.s0.jjj)), ((X.s0.k*8) + X.s0.kkk))
            Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = ((let t3 = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) in select(((X.s0.kkk == 0) && (X.s0.k == 0)), 0.000000f, t3)) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
            if (((X.s0.kkk == 7) && (X.s0.k == ((A.extent.0/8) + -1)))) {
             Out(X.s0.jjj, X.s0.iii, X.s0.jj, X.s0.ii, X.s0.j, X.s0.i) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}


Canonicalizing GPU var names...
Lowering after canonicalizing GPU var names:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
 assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
 assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
 assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
 assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
 assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
 assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
 assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
 assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
 let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
 let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
 let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
 let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
 let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
 let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
 let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
 assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii.__thread_id_y, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj.__thread_id_x, 0, 8) {
     realize X[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
      realize Y[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
       realize Z[0, 8], [0, 32], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1] of type `float32' {
        for (X.s0.k, 0, (A.extent.0/8)) {
         for (X.s0.iii, 0, 32) {
          vectorized (X.s0.jjj, 0, 8) {
           for (X.s0.kkk, 0, 8) {
            X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)A(((X.s0.k*8) + X.s0.kkk), ((X.s0.i.__block_id_y*64) + ((X.s0.ii.__thread_id_y*32) + X.s0.iii)))
            Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = (float32)B(((X.s0.j.__block_id_x*64) + ((X.s0.jj.__thread_id_x*8) + X.s0.jjj)), ((X.s0.k*8) + X.s0.kkk))
            Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) = ((let t3 = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0) in select(((X.s0.kkk == 0) && (X.s0.k == 0)), 0.000000f, t3)) + (X(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)*Y(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)))
            if (((X.s0.kkk == 7) && (X.s0.k == ((A.extent.0/8) + -1)))) {
             Out(X.s0.jjj, X.s0.iii, X.s0.jj.__thread_id_x, X.s0.ii.__thread_id_y, X.s0.j.__block_id_x, X.s0.i.__block_id_y) = Z(X.s0.jjj, X.s0.iii, 0, 0, 0, 0, 0, 0, 0)
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
}

Performing storage flattening...
Lowering after storage flattening:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer) || ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer) || (uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)))) {
 assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
 assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
 assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
 assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
 assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
 assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
 assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
 assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
 assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
 assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
 assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
 assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
 assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
 assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
 assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
 assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
 assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
 assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
 assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
 assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
 assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
 assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
 assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
 assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
 assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
 let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
 let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
 let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
 let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
 let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
 let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
 let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
 assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
 assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
 assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
 assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
 assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
 assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
 assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
 assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
 assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
 assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
 assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
 gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
  gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
   gpu_thread<Default_GPU> (X.s0.ii.__thread_id_y, 0, 2) {
    gpu_thread<Default_GPU> (X.s0.jj.__thread_id_x, 0, 8) {
     let X.extent.0 = 8
     let X.min.0 = 0
     let X.extent.1 = 32
     let X.min.1 = 0
     let X.extent.2 = 1
     let X.min.2 = 0
     let X.extent.3 = 1
     let X.min.3 = 0
     let X.extent.4 = 1
     let X.min.4 = 0
     let X.extent.5 = 1
     let X.min.5 = 0
     let X.extent.6 = 1
     let X.min.6 = 0
     let X.extent.7 = 1
     let X.min.7 = 0
     let X.extent.8 = 1
     let X.min.8 = 0
     let X.stride.0 = 1
     let X.stride.1 = (X.stride.0*8)
     let X.stride.2 = (X.stride.1*32)
     let X.stride.3 = (X.stride.2*1)
     let X.stride.4 = (X.stride.3*1)
     let X.stride.5 = (X.stride.4*1)
     let X.stride.6 = (X.stride.5*1)
     let X.stride.7 = (X.stride.6*1)
     let X.stride.8 = (X.stride.7*1)
     allocate X[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
     let X.buffer = (let t18 = ((halide_dimension_t *))make_struct(X.min.0, X.extent.0, X.stride.0, 0, X.min.1, X.extent.1, X.stride.1, 0, X.min.2, X.extent.2, X.stride.2, 0, X.min.3, X.extent.3, X.stride.3, 0, X.min.4, X.extent.4, X.stride.4, 0, X.min.5, X.extent.5, X.stride.5, 0, X.min.6, X.extent.6, X.stride.6, 0, X.min.7, X.extent.7, X.stride.7, 0, X.min.8, X.extent.8, X.stride.8, 0) in ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))alloca(size_of_halide_buffer_t()), t18, X, (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 9, t18, (uint64)0))
     let Y.extent.0 = 8
     let Y.min.0 = 0
     let Y.extent.1 = 32
     let Y.min.1 = 0
     let Y.extent.2 = 1
     let Y.min.2 = 0
     let Y.extent.3 = 1
     let Y.min.3 = 0
     let Y.extent.4 = 1
     let Y.min.4 = 0
     let Y.extent.5 = 1
     let Y.min.5 = 0
     let Y.extent.6 = 1
     let Y.min.6 = 0
     let Y.extent.7 = 1
     let Y.min.7 = 0
     let Y.extent.8 = 1
     let Y.min.8 = 0
     let Y.stride.0 = 1
     let Y.stride.1 = (Y.stride.0*8)
     let Y.stride.2 = (Y.stride.1*32)
     let Y.stride.3 = (Y.stride.2*1)
     let Y.stride.4 = (Y.stride.3*1)
     let Y.stride.5 = (Y.stride.4*1)
     let Y.stride.6 = (Y.stride.5*1)
     let Y.stride.7 = (Y.stride.6*1)
     let Y.stride.8 = (Y.stride.7*1)
     allocate Y[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
     let Y.buffer = (let t17 = ((halide_dimension_t *))make_struct(Y.min.0, Y.extent.0, Y.stride.0, 0, Y.min.1, Y.extent.1, Y.stride.1, 0, Y.min.2, Y.extent.2, Y.stride.2, 0, Y.min.3, Y.extent.3, Y.stride.3, 0, Y.min.4, Y.extent.4, Y.stride.4, 0, Y.min.5, Y.extent.5, Y.stride.5, 0, Y.min.6, Y.extent.6, Y.stride.6, 0, Y.min.7, Y.extent.7, Y.stride.7, 0, Y.min.8, Y.extent.8, Y.stride.8, 0) in ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))alloca(size_of_halide_buffer_t()), t17, Y, (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 9, t17, (uint64)0))
     let Z.extent.0 = 8
     let Z.min.0 = 0
     let Z.extent.1 = 32
     let Z.min.1 = 0
     let Z.extent.2 = 1
     let Z.min.2 = 0
     let Z.extent.3 = 1
     let Z.min.3 = 0
     let Z.extent.4 = 1
     let Z.min.4 = 0
     let Z.extent.5 = 1
     let Z.min.5 = 0
     let Z.extent.6 = 1
     let Z.min.6 = 0
     let Z.extent.7 = 1
     let Z.min.7 = 0
     let Z.extent.8 = 1
     let Z.min.8 = 0
     let Z.stride.0 = 1
     let Z.stride.1 = (Z.stride.0*8)
     let Z.stride.2 = (Z.stride.1*32)
     let Z.stride.3 = (Z.stride.2*1)
     let Z.stride.4 = (Z.stride.3*1)
     let Z.stride.5 = (Z.stride.4*1)
     let Z.stride.6 = (Z.stride.5*1)
     let Z.stride.7 = (Z.stride.6*1)
     let Z.stride.8 = (Z.stride.7*1)
     allocate Z[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
     let Z.buffer = (let t16 = ((halide_dimension_t *))make_struct(Z.min.0, Z.extent.0, Z.stride.0, 0, Z.min.1, Z.extent.1, Z.stride.1, 0, Z.min.2, Z.extent.2, Z.stride.2, 0, Z.min.3, Z.extent.3, Z.stride.3, 0, Z.min.4, Z.extent.4, Z.stride.4, 0, Z.min.5, Z.extent.5, Z.stride.5, 0, Z.min.6, Z.extent.6, Z.stride.6, 0, Z.min.7, Z.extent.7, Z.stride.7, 0, Z.min.8, Z.extent.8, Z.stride.8, 0) in ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))alloca(size_of_halide_buffer_t()), t16, Z, (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 9, t16, (uint64)0))
     for (X.s0.k, 0, (A.extent.0/8)) {
      for (X.s0.iii, 0, 32) {
       vectorized (X.s0.jjj, 0, 8) {
        for (X.s0.kkk, 0, 8) {
         X[(((((((((0 + ((X.s0.jjj - X.min.0)*X.stride.0)) + ((X.s0.iii - X.min.1)*X.stride.1)) + ((0 - X.min.2)*X.stride.2)) + ((0 - X.min.3)*X.stride.3)) + ((0 - X.min.4)*X.stride.4)) + ((0 - X.min.5)*X.stride.5)) + ((0 - X.min.6)*X.stride.6)) + ((0 - X.min.7)*X.stride.7)) + ((0 - X.min.8)*X.stride.8))] = (float32)A[(((0 + (((X.s0.k*8) + X.s0.kkk)*A.stride.0)) + (((X.s0.i.__block_id_y*64) + ((X.s0.ii.__thread_id_y*32) + X.s0.iii))*A.stride.1)) - ((0 + (A.min.0*A.stride.0)) + (A.min.1*A.stride.1)))]
         Y[(((((((((0 + ((X.s0.jjj - Y.min.0)*Y.stride.0)) + ((X.s0.iii - Y.min.1)*Y.stride.1)) + ((0 - Y.min.2)*Y.stride.2)) + ((0 - Y.min.3)*Y.stride.3)) + ((0 - Y.min.4)*Y.stride.4)) + ((0 - Y.min.5)*Y.stride.5)) + ((0 - Y.min.6)*Y.stride.6)) + ((0 - Y.min.7)*Y.stride.7)) + ((0 - Y.min.8)*Y.stride.8))] = (float32)B[(((0 + (((X.s0.j.__block_id_x*64) + ((X.s0.jj.__thread_id_x*8) + X.s0.jjj))*B.stride.0)) + (((X.s0.k*8) + X.s0.kkk)*B.stride.1)) - ((0 + (B.min.0*B.stride.0)) + (B.min.1*B.stride.1)))]
         Z[(((((((((0 + ((X.s0.jjj - Z.min.0)*Z.stride.0)) + ((X.s0.iii - Z.min.1)*Z.stride.1)) + ((0 - Z.min.2)*Z.stride.2)) + ((0 - Z.min.3)*Z.stride.3)) + ((0 - Z.min.4)*Z.stride.4)) + ((0 - Z.min.5)*Z.stride.5)) + ((0 - Z.min.6)*Z.stride.6)) + ((0 - Z.min.7)*Z.stride.7)) + ((0 - Z.min.8)*Z.stride.8))] = ((let t3 = Z[(((((((((0 + ((X.s0.jjj - Z.min.0)*Z.stride.0)) + ((X.s0.iii - Z.min.1)*Z.stride.1)) + ((0 - Z.min.2)*Z.stride.2)) + ((0 - Z.min.3)*Z.stride.3)) + ((0 - Z.min.4)*Z.stride.4)) + ((0 - Z.min.5)*Z.stride.5)) + ((0 - Z.min.6)*Z.stride.6)) + ((0 - Z.min.7)*Z.stride.7)) + ((0 - Z.min.8)*Z.stride.8))] in select(((X.s0.kkk == 0) && (X.s0.k == 0)), 0.000000f, t3)) + (X[(((((((((0 + ((X.s0.jjj - X.min.0)*X.stride.0)) + ((X.s0.iii - X.min.1)*X.stride.1)) + ((0 - X.min.2)*X.stride.2)) + ((0 - X.min.3)*X.stride.3)) + ((0 - X.min.4)*X.stride.4)) + ((0 - X.min.5)*X.stride.5)) + ((0 - X.min.6)*X.stride.6)) + ((0 - X.min.7)*X.stride.7)) + ((0 - X.min.8)*X.stride.8))]*Y[(((((((((0 + ((X.s0.jjj - Y.min.0)*Y.stride.0)) + ((X.s0.iii - Y.min.1)*Y.stride.1)) + ((0 - Y.min.2)*Y.stride.2)) + ((0 - Y.min.3)*Y.stride.3)) + ((0 - Y.min.4)*Y.stride.4)) + ((0 - Y.min.5)*Y.stride.5)) + ((0 - Y.min.6)*Y.stride.6)) + ((0 - Y.min.7)*Y.stride.7)) + ((0 - Y.min.8)*Y.stride.8))]))
         if (((X.s0.kkk == 7) && (X.s0.k == ((A.extent.0/8) + -1)))) {
          Out[(((((((0 + (X.s0.jjj*Out.stride.0)) + (X.s0.iii*Out.stride.1)) + (X.s0.jj.__thread_id_x*Out.stride.2)) + (X.s0.ii.__thread_id_y*Out.stride.3)) + (X.s0.j.__block_id_x*Out.stride.4)) + (X.s0.i.__block_id_y*Out.stride.5)) - ((((((0 + (Out.min.0*Out.stride.0)) + (Out.min.1*Out.stride.1)) + (Out.min.2*Out.stride.2)) + (Out.min.3*Out.stride.3)) + (Out.min.4*Out.stride.4)) + (Out.min.5*Out.stride.5)))] = Z[(((((((((0 + ((X.s0.jjj - Z.min.0)*Z.stride.0)) + ((X.s0.iii - Z.min.1)*Z.stride.1)) + ((0 - Z.min.2)*Z.stride.2)) + ((0 - Z.min.3)*Z.stride.3)) + ((0 - Z.min.4)*Z.stride.4)) + ((0 - Z.min.5)*Z.stride.5)) + ((0 - Z.min.6)*Z.stride.6)) + ((0 - Z.min.7)*Z.stride.7)) + ((0 - Z.min.8)*Z.stride.8))]
         }
        }
       }
      }
     }
    }
   }
  }
 }
}


Applying memory schedule...
Lowering after memory schedule:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj.__thread_id_x, 0, 8) {
    allocate B_im_buf[float32 * 8 * 8] in Register
    allocate A_im_buf[float32 * 8 * 32] in Register
    let X.extent.0 = 8
    let X.min.0 = 0
    let X.extent.1 = 32
    let X.min.1 = 0
    let X.extent.2 = 1
    let X.min.2 = 0
    let X.extent.3 = 1
    let X.min.3 = 0
    let X.extent.4 = 1
    let X.min.4 = 0
    let X.extent.5 = 1
    let X.min.5 = 0
    let X.extent.6 = 1
    let X.min.6 = 0
    let X.extent.7 = 1
    let X.min.7 = 0
    let X.extent.8 = 1
    let X.min.8 = 0
    let X.stride.0 = 1
    let X.stride.1 = (X.stride.0*8)
    let X.stride.2 = (X.stride.1*32)
    let X.stride.3 = (X.stride.2*1)
    let X.stride.4 = (X.stride.3*1)
    let X.stride.5 = (X.stride.4*1)
    let X.stride.6 = (X.stride.5*1)
    let X.stride.7 = (X.stride.6*1)
    let X.stride.8 = (X.stride.7*1)
    allocate X[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    let X.buffer = (let t18 = ((halide_dimension_t *))make_struct(X.min.0, X.extent.0, X.stride.0, 0, X.min.1, X.extent.1, X.stride.1, 0, X.min.2, X.extent.2, X.stride.2, 0, X.min.3, X.extent.3, X.stride.3, 0, X.min.4, X.extent.4, X.stride.4, 0, X.min.5, X.extent.5, X.stride.5, 0, X.min.6, X.extent.6, X.stride.6, 0, X.min.7, X.extent.7, X.stride.7, 0, X.min.8, X.extent.8, X.stride.8, 0) in ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))alloca(size_of_halide_buffer_t()), t18, X, (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 9, t18, (uint64)0))
    let Y.extent.0 = 8
    let Y.min.0 = 0
    let Y.extent.1 = 32
    let Y.min.1 = 0
    let Y.extent.2 = 1
    let Y.min.2 = 0
    let Y.extent.3 = 1
    let Y.min.3 = 0
    let Y.extent.4 = 1
    let Y.min.4 = 0
    let Y.extent.5 = 1
    let Y.min.5 = 0
    let Y.extent.6 = 1
    let Y.min.6 = 0
    let Y.extent.7 = 1
    let Y.min.7 = 0
    let Y.extent.8 = 1
    let Y.min.8 = 0
    let Y.stride.0 = 1
    let Y.stride.1 = (Y.stride.0*8)
    let Y.stride.2 = (Y.stride.1*32)
    let Y.stride.3 = (Y.stride.2*1)
    let Y.stride.4 = (Y.stride.3*1)
    let Y.stride.5 = (Y.stride.4*1)
    let Y.stride.6 = (Y.stride.5*1)
    let Y.stride.7 = (Y.stride.6*1)
    let Y.stride.8 = (Y.stride.7*1)
    allocate Y[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    let Y.buffer = (let t17 = ((halide_dimension_t *))make_struct(Y.min.0, Y.extent.0, Y.stride.0, 0, Y.min.1, Y.extent.1, Y.stride.1, 0, Y.min.2, Y.extent.2, Y.stride.2, 0, Y.min.3, Y.extent.3, Y.stride.3, 0, Y.min.4, Y.extent.4, Y.stride.4, 0, Y.min.5, Y.extent.5, Y.stride.5, 0, Y.min.6, Y.extent.6, Y.stride.6, 0, Y.min.7, Y.extent.7, Y.stride.7, 0, Y.min.8, Y.extent.8, Y.stride.8, 0) in ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))alloca(size_of_halide_buffer_t()), t17, Y, (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 9, t17, (uint64)0))
    let Z.extent.0 = 8
    let Z.min.0 = 0
    let Z.extent.1 = 32
    let Z.min.1 = 0
    let Z.extent.2 = 1
    let Z.min.2 = 0
    let Z.extent.3 = 1
    let Z.min.3 = 0
    let Z.extent.4 = 1
    let Z.min.4 = 0
    let Z.extent.5 = 1
    let Z.min.5 = 0
    let Z.extent.6 = 1
    let Z.min.6 = 0
    let Z.extent.7 = 1
    let Z.min.7 = 0
    let Z.extent.8 = 1
    let Z.min.8 = 0
    let Z.stride.0 = 1
    let Z.stride.1 = (Z.stride.0*8)
    let Z.stride.2 = (Z.stride.1*32)
    let Z.stride.3 = (Z.stride.2*1)
    let Z.stride.4 = (Z.stride.3*1)
    let Z.stride.5 = (Z.stride.4*1)
    let Z.stride.6 = (Z.stride.5*1)
    let Z.stride.7 = (Z.stride.6*1)
    let Z.stride.8 = (Z.stride.7*1)
    allocate Z[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    let Z.buffer = (let t16 = ((halide_dimension_t *))make_struct(Z.min.0, Z.extent.0, Z.stride.0, 0, Z.min.1, Z.extent.1, Z.stride.1, 0, Z.min.2, Z.extent.2, Z.stride.2, 0, Z.min.3, Z.extent.3, Z.stride.3, 0, Z.min.4, Z.extent.4, Z.stride.4, 0, Z.min.5, Z.extent.5, Z.stride.5, 0, Z.min.6, Z.extent.6, Z.stride.6, 0, Z.min.7, Z.extent.7, Z.stride.7, 0, Z.min.8, Z.extent.8, Z.stride.8, 0) in ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))alloca(size_of_halide_buffer_t()), t16, Z, (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 9, t16, (uint64)0))
    if ((uint1)1) {
     Z[ramp(0, 1, 256)] = x256(0.000000f)
    }
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
     (float32)cm_load_2d(((void *))B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(((void *))A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      vectorized (X.s0.jjj, 0, 8) {
       punrolled (X.s0.kkk, 0, 8) {
        0
        0
        Z[(((((((((0 + ((X.s0.jjj - Z.min.0)*Z.stride.0)) + ((X.s0.iii - Z.min.1)*Z.stride.1)) + ((0 - Z.min.2)*Z.stride.2)) + ((0 - Z.min.3)*Z.stride.3)) + ((0 - Z.min.4)*Z.stride.4)) + ((0 - Z.min.5)*Z.stride.5)) + ((0 - Z.min.6)*Z.stride.6)) + ((0 - Z.min.7)*Z.stride.7)) + ((0 - Z.min.8)*Z.stride.8))] = ((let t3 = Z[(((((((((0 + ((X.s0.jjj - Z.min.0)*Z.stride.0)) + ((X.s0.iii - Z.min.1)*Z.stride.1)) + ((0 - Z.min.2)*Z.stride.2)) + ((0 - Z.min.3)*Z.stride.3)) + ((0 - Z.min.4)*Z.stride.4)) + ((0 - Z.min.5)*Z.stride.5)) + ((0 - Z.min.6)*Z.stride.6)) + ((0 - Z.min.7)*Z.stride.7)) + ((0 - Z.min.8)*Z.stride.8))] in t3) + (A_im_buf[((0 + ((0*8) + X.s0.kkk)) + (X.s0.iii*8))]*B_im_buf[((0 + X.s0.jjj) + (((0*8) + X.s0.kkk)*8))]))
       }
      }
     }
    }
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
    unrolled (Out.store.t0, 0, 1) {
     (float32x256)cm_store_2d(((void *))Out, (var.Out.store.addr.0 + 0), (var.Out.store.addr.1 + 0), Z, ramp((Out.store.t0*256), 1, 256), 8, 32, "C")
    }
   }
  }
 }
}


Adding atomic mutex allocation...
Lowering after adding atomic mutex allocation:
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert(((uint32)A.type == (uint32)73730), halide_error_bad_type("Input buffer A", (uint32)A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert(((uint32)B.type == (uint32)73730), halide_error_bad_type("Input buffer B", (uint32)B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert(((uint32)Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", (uint32)Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj.__thread_id_x, 0, 8) {
    allocate B_im_buf[float32 * 8 * 8] in Register
    allocate A_im_buf[float32 * 8 * 32] in Register
    let X.extent.0 = 8
    let X.min.0 = 0
    let X.extent.1 = 32
    let X.min.1 = 0
    let X.extent.2 = 1
    let X.min.2 = 0
    let X.extent.3 = 1
    let X.min.3 = 0
    let X.extent.4 = 1
    let X.min.4 = 0
    let X.extent.5 = 1
    let X.min.5 = 0
    let X.extent.6 = 1
    let X.min.6 = 0
    let X.extent.7 = 1
    let X.min.7 = 0
    let X.extent.8 = 1
    let X.min.8 = 0
    let X.stride.0 = 1
    let X.stride.1 = (X.stride.0*8)
    let X.stride.2 = (X.stride.1*32)
    let X.stride.3 = (X.stride.2*1)
    let X.stride.4 = (X.stride.3*1)
    let X.stride.5 = (X.stride.4*1)
    let X.stride.6 = (X.stride.5*1)
    let X.stride.7 = (X.stride.6*1)
    let X.stride.8 = (X.stride.7*1)
    allocate X[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    let X.buffer = (let t18 = ((halide_dimension_t *))make_struct(X.min.0, X.extent.0, X.stride.0, 0, X.min.1, X.extent.1, X.stride.1, 0, X.min.2, X.extent.2, X.stride.2, 0, X.min.3, X.extent.3, X.stride.3, 0, X.min.4, X.extent.4, X.stride.4, 0, X.min.5, X.extent.5, X.stride.5, 0, X.min.6, X.extent.6, X.stride.6, 0, X.min.7, X.extent.7, X.stride.7, 0, X.min.8, X.extent.8, X.stride.8, 0) in ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))alloca(size_of_halide_buffer_t()), t18, X, (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 9, t18, (uint64)0))
    let Y.extent.0 = 8
    let Y.min.0 = 0
    let Y.extent.1 = 32
    let Y.min.1 = 0
    let Y.extent.2 = 1
    let Y.min.2 = 0
    let Y.extent.3 = 1
    let Y.min.3 = 0
    let Y.extent.4 = 1
    let Y.min.4 = 0
    let Y.extent.5 = 1
    let Y.min.5 = 0
    let Y.extent.6 = 1
    let Y.min.6 = 0
    let Y.extent.7 = 1
    let Y.min.7 = 0
    let Y.extent.8 = 1
    let Y.min.8 = 0
    let Y.stride.0 = 1
    let Y.stride.1 = (Y.stride.0*8)
    let Y.stride.2 = (Y.stride.1*32)
    let Y.stride.3 = (Y.stride.2*1)
    let Y.stride.4 = (Y.stride.3*1)
    let Y.stride.5 = (Y.stride.4*1)
    let Y.stride.6 = (Y.stride.5*1)
    let Y.stride.7 = (Y.stride.6*1)
    let Y.stride.8 = (Y.stride.7*1)
    allocate Y[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    let Y.buffer = (let t17 = ((halide_dimension_t *))make_struct(Y.min.0, Y.extent.0, Y.stride.0, 0, Y.min.1, Y.extent.1, Y.stride.1, 0, Y.min.2, Y.extent.2, Y.stride.2, 0, Y.min.3, Y.extent.3, Y.stride.3, 0, Y.min.4, Y.extent.4, Y.stride.4, 0, Y.min.5, Y.extent.5, Y.stride.5, 0, Y.min.6, Y.extent.6, Y.stride.6, 0, Y.min.7, Y.extent.7, Y.stride.7, 0, Y.min.8, Y.extent.8, Y.stride.8, 0) in ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))alloca(size_of_halide_buffer_t()), t17, Y, (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 9, t17, (uint64)0))
    let Z.extent.0 = 8
    let Z.min.0 = 0
    let Z.extent.1 = 32
    let Z.min.1 = 0
    let Z.extent.2 = 1
    let Z.min.2 = 0
    let Z.extent.3 = 1
    let Z.min.3 = 0
    let Z.extent.4 = 1
    let Z.min.4 = 0
    let Z.extent.5 = 1
    let Z.min.5 = 0
    let Z.extent.6 = 1
    let Z.min.6 = 0
    let Z.extent.7 = 1
    let Z.min.7 = 0
    let Z.extent.8 = 1
    let Z.min.8 = 0
    let Z.stride.0 = 1
    let Z.stride.1 = (Z.stride.0*8)
    let Z.stride.2 = (Z.stride.1*32)
    let Z.stride.3 = (Z.stride.2*1)
    let Z.stride.4 = (Z.stride.3*1)
    let Z.stride.5 = (Z.stride.4*1)
    let Z.stride.6 = (Z.stride.5*1)
    let Z.stride.7 = (Z.stride.6*1)
    let Z.stride.8 = (Z.stride.7*1)
    allocate Z[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    let Z.buffer = (let t16 = ((halide_dimension_t *))make_struct(Z.min.0, Z.extent.0, Z.stride.0, 0, Z.min.1, Z.extent.1, Z.stride.1, 0, Z.min.2, Z.extent.2, Z.stride.2, 0, Z.min.3, Z.extent.3, Z.stride.3, 0, Z.min.4, Z.extent.4, Z.stride.4, 0, Z.min.5, Z.extent.5, Z.stride.5, 0, Z.min.6, Z.extent.6, Z.stride.6, 0, Z.min.7, Z.extent.7, Z.stride.7, 0, Z.min.8, Z.extent.8, Z.stride.8, 0) in ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))alloca(size_of_halide_buffer_t()), t16, Z, (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 9, t16, (uint64)0))
    if ((uint1)1) {
     Z[ramp(0, 1, 256)] = x256(0.000000f)
    }
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
     (float32)cm_load_2d(((void *))B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(((void *))A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      vectorized (X.s0.jjj, 0, 8) {
       punrolled (X.s0.kkk, 0, 8) {
        0
        0
        Z[(((((((((0 + ((X.s0.jjj - Z.min.0)*Z.stride.0)) + ((X.s0.iii - Z.min.1)*Z.stride.1)) + ((0 - Z.min.2)*Z.stride.2)) + ((0 - Z.min.3)*Z.stride.3)) + ((0 - Z.min.4)*Z.stride.4)) + ((0 - Z.min.5)*Z.stride.5)) + ((0 - Z.min.6)*Z.stride.6)) + ((0 - Z.min.7)*Z.stride.7)) + ((0 - Z.min.8)*Z.stride.8))] = ((let t3 = Z[(((((((((0 + ((X.s0.jjj - Z.min.0)*Z.stride.0)) + ((X.s0.iii - Z.min.1)*Z.stride.1)) + ((0 - Z.min.2)*Z.stride.2)) + ((0 - Z.min.3)*Z.stride.3)) + ((0 - Z.min.4)*Z.stride.4)) + ((0 - Z.min.5)*Z.stride.5)) + ((0 - Z.min.6)*Z.stride.6)) + ((0 - Z.min.7)*Z.stride.7)) + ((0 - Z.min.8)*Z.stride.8))] in t3) + (A_im_buf[((0 + ((0*8) + X.s0.kkk)) + (X.s0.iii*8))]*B_im_buf[((0 + X.s0.jjj) + (((0*8) + X.s0.kkk)*8))]))
       }
      }
     }
    }
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
    unrolled (Out.store.t0, 0, 1) {
     (float32x256)cm_store_2d(((void *))Out, (var.Out.store.addr.0 + 0), (var.Out.store.addr.1 + 0), Z, ramp((Out.store.t0*256), 1, 256), 8, 32, "C")
    }
   }
  }
 }
}


Unpacking buffer arguments...
Lowering after unpacking buffer arguments...
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj.__thread_id_x, 0, 8) {
    allocate B_im_buf[float32 * 8 * 8] in Register
    allocate A_im_buf[float32 * 8 * 32] in Register
    let X.extent.0 = 8
    let X.min.0 = 0
    let X.extent.1 = 32
    let X.min.1 = 0
    let X.extent.2 = 1
    let X.min.2 = 0
    let X.extent.3 = 1
    let X.min.3 = 0
    let X.extent.4 = 1
    let X.min.4 = 0
    let X.extent.5 = 1
    let X.min.5 = 0
    let X.extent.6 = 1
    let X.min.6 = 0
    let X.extent.7 = 1
    let X.min.7 = 0
    let X.extent.8 = 1
    let X.min.8 = 0
    let X.stride.0 = 1
    let X.stride.1 = (X.stride.0*8)
    let X.stride.2 = (X.stride.1*32)
    let X.stride.3 = (X.stride.2*1)
    let X.stride.4 = (X.stride.3*1)
    let X.stride.5 = (X.stride.4*1)
    let X.stride.6 = (X.stride.5*1)
    let X.stride.7 = (X.stride.6*1)
    let X.stride.8 = (X.stride.7*1)
    allocate X[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    let X.buffer = (let t18 = ((halide_dimension_t *))make_struct(X.min.0, X.extent.0, X.stride.0, 0, X.min.1, X.extent.1, X.stride.1, 0, X.min.2, X.extent.2, X.stride.2, 0, X.min.3, X.extent.3, X.stride.3, 0, X.min.4, X.extent.4, X.stride.4, 0, X.min.5, X.extent.5, X.stride.5, 0, X.min.6, X.extent.6, X.stride.6, 0, X.min.7, X.extent.7, X.stride.7, 0, X.min.8, X.extent.8, X.stride.8, 0) in ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))alloca(size_of_halide_buffer_t()), t18, X, (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 9, t18, (uint64)0))
    let Y.extent.0 = 8
    let Y.min.0 = 0
    let Y.extent.1 = 32
    let Y.min.1 = 0
    let Y.extent.2 = 1
    let Y.min.2 = 0
    let Y.extent.3 = 1
    let Y.min.3 = 0
    let Y.extent.4 = 1
    let Y.min.4 = 0
    let Y.extent.5 = 1
    let Y.min.5 = 0
    let Y.extent.6 = 1
    let Y.min.6 = 0
    let Y.extent.7 = 1
    let Y.min.7 = 0
    let Y.extent.8 = 1
    let Y.min.8 = 0
    let Y.stride.0 = 1
    let Y.stride.1 = (Y.stride.0*8)
    let Y.stride.2 = (Y.stride.1*32)
    let Y.stride.3 = (Y.stride.2*1)
    let Y.stride.4 = (Y.stride.3*1)
    let Y.stride.5 = (Y.stride.4*1)
    let Y.stride.6 = (Y.stride.5*1)
    let Y.stride.7 = (Y.stride.6*1)
    let Y.stride.8 = (Y.stride.7*1)
    allocate Y[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    let Y.buffer = (let t17 = ((halide_dimension_t *))make_struct(Y.min.0, Y.extent.0, Y.stride.0, 0, Y.min.1, Y.extent.1, Y.stride.1, 0, Y.min.2, Y.extent.2, Y.stride.2, 0, Y.min.3, Y.extent.3, Y.stride.3, 0, Y.min.4, Y.extent.4, Y.stride.4, 0, Y.min.5, Y.extent.5, Y.stride.5, 0, Y.min.6, Y.extent.6, Y.stride.6, 0, Y.min.7, Y.extent.7, Y.stride.7, 0, Y.min.8, Y.extent.8, Y.stride.8, 0) in ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))alloca(size_of_halide_buffer_t()), t17, Y, (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 9, t17, (uint64)0))
    let Z.extent.0 = 8
    let Z.min.0 = 0
    let Z.extent.1 = 32
    let Z.min.1 = 0
    let Z.extent.2 = 1
    let Z.min.2 = 0
    let Z.extent.3 = 1
    let Z.min.3 = 0
    let Z.extent.4 = 1
    let Z.min.4 = 0
    let Z.extent.5 = 1
    let Z.min.5 = 0
    let Z.extent.6 = 1
    let Z.min.6 = 0
    let Z.extent.7 = 1
    let Z.min.7 = 0
    let Z.extent.8 = 1
    let Z.min.8 = 0
    let Z.stride.0 = 1
    let Z.stride.1 = (Z.stride.0*8)
    let Z.stride.2 = (Z.stride.1*32)
    let Z.stride.3 = (Z.stride.2*1)
    let Z.stride.4 = (Z.stride.3*1)
    let Z.stride.5 = (Z.stride.4*1)
    let Z.stride.6 = (Z.stride.5*1)
    let Z.stride.7 = (Z.stride.6*1)
    let Z.stride.8 = (Z.stride.7*1)
    allocate Z[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    let Z.buffer = (let t16 = ((halide_dimension_t *))make_struct(Z.min.0, Z.extent.0, Z.stride.0, 0, Z.min.1, Z.extent.1, Z.stride.1, 0, Z.min.2, Z.extent.2, Z.stride.2, 0, Z.min.3, Z.extent.3, Z.stride.3, 0, Z.min.4, Z.extent.4, Z.stride.4, 0, Z.min.5, Z.extent.5, Z.stride.5, 0, Z.min.6, Z.extent.6, Z.stride.6, 0, Z.min.7, Z.extent.7, Z.stride.7, 0, Z.min.8, Z.extent.8, Z.stride.8, 0) in ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))alloca(size_of_halide_buffer_t()), t16, Z, (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 9, t16, (uint64)0))
    if ((uint1)1) {
     Z[ramp(0, 1, 256)] = x256(0.000000f)
    }
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      vectorized (X.s0.jjj, 0, 8) {
       punrolled (X.s0.kkk, 0, 8) {
        0
        0
        Z[(((((((((0 + ((X.s0.jjj - Z.min.0)*Z.stride.0)) + ((X.s0.iii - Z.min.1)*Z.stride.1)) + ((0 - Z.min.2)*Z.stride.2)) + ((0 - Z.min.3)*Z.stride.3)) + ((0 - Z.min.4)*Z.stride.4)) + ((0 - Z.min.5)*Z.stride.5)) + ((0 - Z.min.6)*Z.stride.6)) + ((0 - Z.min.7)*Z.stride.7)) + ((0 - Z.min.8)*Z.stride.8))] = ((let t3 = Z[(((((((((0 + ((X.s0.jjj - Z.min.0)*Z.stride.0)) + ((X.s0.iii - Z.min.1)*Z.stride.1)) + ((0 - Z.min.2)*Z.stride.2)) + ((0 - Z.min.3)*Z.stride.3)) + ((0 - Z.min.4)*Z.stride.4)) + ((0 - Z.min.5)*Z.stride.5)) + ((0 - Z.min.6)*Z.stride.6)) + ((0 - Z.min.7)*Z.stride.7)) + ((0 - Z.min.8)*Z.stride.8))] in t3) + (A_im_buf[((0 + ((0*8) + X.s0.kkk)) + (X.s0.iii*8))]*B_im_buf[((0 + X.s0.jjj) + (((0*8) + X.s0.kkk)*8))]))
       }
      }
     }
    }
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
    unrolled (Out.store.t0, 0, 1) {
     (float32x256)cm_store_2d(Out, (var.Out.store.addr.0 + 0), (var.Out.store.addr.1 + 0), Z, ramp((Out.store.t0*256), 1, 256), 8, 32, "C")
    }
   }
  }
 }
}


Skipping rewriting memoized allocations...
Second simplification...
Lowering after second simplifcation:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj.__thread_id_x, 0, 8) {
    allocate B_im_buf[float32 * 8 * 8] in Register
    allocate A_im_buf[float32 * 8 * 32] in Register
    allocate X[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Y[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Z[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      vectorized (X.s0.jjj, 0, 8) {
       punrolled (X.s0.kkk, 0, 8) {
        Z[((X.s0.iii*8) + X.s0.jjj)] = ((let t3 = Z[((X.s0.iii*8) + X.s0.jjj)] in t3) + (A_im_buf[((X.s0.iii*8) + X.s0.kkk)]*B_im_buf[((X.s0.kkk*8) + X.s0.jjj)]))
       }
      }
     }
    }
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
   }
  }
 }
}


Reduce prefetch dimension...
Lowering after reduce prefetch dimension:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj.__thread_id_x, 0, 8) {
    allocate B_im_buf[float32 * 8 * 8] in Register
    allocate A_im_buf[float32 * 8 * 32] in Register
    allocate X[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Y[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Z[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      vectorized (X.s0.jjj, 0, 8) {
       punrolled (X.s0.kkk, 0, 8) {
        Z[((X.s0.iii*8) + X.s0.jjj)] = ((let t3 = Z[((X.s0.iii*8) + X.s0.jjj)] in t3) + (A_im_buf[((X.s0.iii*8) + X.s0.kkk)]*B_im_buf[((X.s0.kkk*8) + X.s0.jjj)]))
       }
      }
     }
    }
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
   }
  }
 }
}

Simplifying correlated differences...
Lowering after simplifying correlated differences:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj.__thread_id_x, 0, 8) {
    allocate B_im_buf[float32 * 8 * 8] in Register
    allocate A_im_buf[float32 * 8 * 32] in Register
    allocate X[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Y[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Z[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      vectorized (X.s0.jjj, 0, 8) {
       punrolled (X.s0.kkk, 0, 8) {
        Z[((X.s0.iii*8) + X.s0.jjj)] = ((let t3 = Z[((X.s0.iii*8) + X.s0.jjj)] in t3) + (A_im_buf[((X.s0.iii*8) + X.s0.kkk)]*B_im_buf[((X.s0.kkk*8) + X.s0.jjj)]))
       }
      }
     }
    }
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
   }
  }
 }
}

Vectorizing...
Lowering after vectorizing:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj.__thread_id_x, 0, 8) {
    allocate B_im_buf[float32 * 8 * 8] in Register
    allocate A_im_buf[float32 * 8 * 32] in Register
    allocate X[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Y[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Z[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[(x8((X.s0.iii*8)) + ramp(0, 1, 8))] = ((let t3.x8 = Z[(x8((X.s0.iii*8)) + ramp(0, 1, 8))] in t3.x8) + (x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])*B_im_buf[(x8((X.s0.kkk*8)) + ramp(0, 1, 8))]))
      }
     }
    }
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
   }
  }
 }
}


Lowering after simplify after vectorizing:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj.__thread_id_x, 0, 8) {
    allocate B_im_buf[float32 * 8 * 8] in Register
    allocate A_im_buf[float32 * 8 * 32] in Register
    allocate X[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Y[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Z[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
   }
  }
 }
}


Combining channels ...
Lowering after combining channels:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj.__thread_id_x, 0, 8) {
    allocate B_im_buf[float32 * 8 * 8] in Register
    allocate A_im_buf[float32 * 8 * 32] in Register
    allocate X[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Y[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Z[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
   }
  }
 }
}


Trimming loops to the region over which they do something...
Lowering after loop trimming:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj.__thread_id_x, 0, 8) {
    allocate B_im_buf[float32 * 8 * 8] in Register
    allocate A_im_buf[float32 * 8 * 32] in Register
    allocate X[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Y[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Z[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
   }
  }
 }
}


Remove Lets and LetStmts in funcs with buffering or scattering...
Lowering after removing Lets and LetStmts in funcs with buffering or scattering:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj.__thread_id_x, 0, 8) {
    allocate B_im_buf[float32 * 8 * 8] in Register
    allocate A_im_buf[float32 * 8 * 32] in Register
    allocate X[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Y[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Z[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
   }
  }
 }
}


Scattering and buffering...
Lowering after Scattering and buffering:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj.__thread_id_x, 0, 8) {
    allocate B_im_buf[float32 * 8 * 8] in Register
    allocate A_im_buf[float32 * 8 * 32] in Register
    allocate X[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Y[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Z[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
   }
  }
 }
}


Gathering...
Lowering after Gathering:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj.__thread_id_x, 0, 8) {
    allocate B_im_buf[float32 * 8 * 8] in Register
    allocate A_im_buf[float32 * 8 * 32] in Register
    allocate X[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Y[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Z[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
   }
  }
 }
}


Unrolling...
Lowering after unrolling:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<Default_GPU> (X.s0.ii.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (X.s0.jj.__thread_id_x, 0, 8) {
    allocate B_im_buf[float32 * 8 * 8] in Register
    allocate A_im_buf[float32 * 8 * 32] in Register
    allocate X[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Y[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    allocate Z[float32 * 8 * 32 * 1 * 1 * 1 * 1 * 1 * 1 * 1]
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + X.s0.ii.__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + X.s0.jj.__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
   }
  }
 }
}


Injecting per-block gpu synchronization...
Lowering after injecting per-block gpu synchronization:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  let group_0.shared_offset = 0
  let sentinel.shared_offset = group_0.shared_offset
  allocate __shared[uint8 * group_0.shared_offset] in GPUShared
  gpu_thread<Default_GPU> (.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate Y[float32 * 256]
    allocate X[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + (.__thread_id_x + 0))*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + (.__thread_id_y + 0))*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + (.__thread_id_y + 0))*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + (.__thread_id_x + 0))*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
   }
  }
 }
}


Partitioning loops to simplify boundary conditions...
Lowering after partitioning loops:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  allocate __shared[uint8 * 0] in GPUShared
  gpu_thread<Default_GPU> (.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate Y[float32 * 256]
    allocate X[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
   }
  }
 }
}


Injecting early frees...
Lowering after injecting early frees:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  allocate __shared[uint8 * 0] in GPUShared
  gpu_thread<Default_GPU> (.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate Y[float32 * 256]
    allocate X[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
    free X
    free Y
   }
  }
  free __shared
 }
}


Simplifying correlated differences...
Lowering after simplifying correlated differences:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  allocate __shared[uint8 * 0] in GPUShared
  gpu_thread<Default_GPU> (.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate Y[float32 * 256]
    allocate X[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
    free X
    free Y
   }
  }
  free __shared
 }
}

Replace memory channel with references...
IR after removing LetStmts in device kernels ...

assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  allocate __shared[uint8 * 0] in GPUShared
  gpu_thread<Default_GPU> (.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate Y[float32 * 256]
    allocate X[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
    free X
    free Y
   }
  }
  free __shared
 }
}

Lowering after replacing memory channels:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<Default_GPU> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<Default_GPU> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  allocate __shared[uint8 * 0] in GPUShared
  gpu_thread<Default_GPU> (.__thread_id_y, 0, 2) {
   gpu_thread<Default_GPU> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate Y[float32 * 256]
    allocate X[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
    free X
    free Y
   }
  }
  free __shared
 }
}


Selecting a GPU API for GPU loops...
Lowering after selecting a GPU API:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<CM> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<CM> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  allocate __shared[uint8 * 0] in GPUShared
  gpu_thread<CM> (.__thread_id_y, 0, 2) {
   gpu_thread<CM> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate Y[float32 * 256]
    allocate X[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
    free X
    free Y
   }
  }
  free __shared
 }
}


Injecting host <-> dev buffer copies...
Lowering after injecting host <-> dev buffer copies:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<CM> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<CM> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  allocate __shared[uint8 * 0] in GPUShared
  gpu_thread<CM> (.__thread_id_y, 0, 2) {
   gpu_thread<CM> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate Y[float32 * 256]
    allocate X[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
    free X
    free Y
   }
  }
  free __shared
 }
}


Selecting a GPU API for extern stages...
Lowering after selecting a GPU API for extern stages:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<CM> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<CM> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  allocate __shared[uint8 * 0] in GPUShared
  gpu_thread<CM> (.__thread_id_y, 0, 2) {
   gpu_thread<CM> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate Y[float32 * 256]
    allocate X[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
    free X
    free Y
   }
  }
  free __shared
 }
}


Bounding small allocations...
Lowering after bounding small allocations:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<CM> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<CM> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  allocate __shared[uint8 * 0] in GPUShared if (uint1)0
  gpu_thread<CM> (.__thread_id_y, 0, 2) {
   gpu_thread<CM> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate Y[float32 * 256]
    allocate X[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = ((let t3.x8 = Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] in t3.x8) + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
    free X
    free Y
   }
  }
  free __shared
 }
}


CSE...
Lowering after CSE:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<CM> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<CM> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  allocate __shared[uint8 * 0] in GPUShared if (uint1)0
  gpu_thread<CM> (.__thread_id_y, 0, 2) {
   gpu_thread<CM> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate Y[float32 * 256]
    allocate X[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = (Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
    free X
    free Y
   }
  }
  free __shared
 }
}


Matching compute patterns...
Lowering after matching patterns:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<CM> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<CM> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  allocate __shared[uint8 * 0] in GPUShared if (uint1)0
  gpu_thread<CM> (.__thread_id_y, 0, 2) {
   gpu_thread<CM> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate Y[float32 * 256]
    allocate X[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = (Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
    free X
    free Y
   }
  }
  free __shared
 }
}


Lowering unsafe promises...
Lowering after lowering unsafe promises:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<CM> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<CM> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  allocate __shared[uint8 * 0] in GPUShared if (uint1)0
  gpu_thread<CM> (.__thread_id_y, 0, 2) {
   gpu_thread<CM> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate Y[float32 * 256]
    allocate X[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = (Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
    free X
    free Y
   }
  }
  free __shared
 }
}


Removing dead allocationss and dimensions...
Lowering after final simplification:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<CM> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<CM> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<CM> (.__thread_id_y, 0, 2) {
   gpu_thread<CM> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = (Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
   }
  }
 }
}


Promoting channels...
Lowering after channel promotion:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<CM> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<CM> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<CM> (.__thread_id_y, 0, 2) {
   gpu_thread<CM> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = (Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
   }
  }
 }
}


Flatten triangular loop...
Lowering after triangular loop optimizing:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<CM> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<CM> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<CM> (.__thread_id_y, 0, 2) {
   gpu_thread<CM> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = (Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
   }
  }
 }
}


Late fuse...
Lowering after late fuse:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<CM> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<CM> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<CM> (.__thread_id_y, 0, 2) {
   gpu_thread<CM> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = (Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
   }
  }
 }
}


Creating overlay scheduler...
Lowering after creating overlay scheduler:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<CM> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<CM> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<CM> (.__thread_id_y, 0, 2) {
   gpu_thread<CM> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = (Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
   }
  }
 }
}


Skipping Hexagon offload...
Remove lets...
Lowering after removing lets:
assert(((uint64)reinterpret(((buffer_t *))Out.buffer) != (uint64)0), halide_error_buffer_argument_is_null("Out"))
assert(((uint64)reinterpret(((buffer_t *))B.buffer) != (uint64)0), halide_error_buffer_argument_is_null("B"))
assert(((uint64)reinterpret(((buffer_t *))A.buffer) != (uint64)0), halide_error_buffer_argument_is_null("A"))
let A = ((void *))_halide_buffer_get_host(((buffer_t *))A.buffer)
let A.type = (uint32)_halide_buffer_get_type(((buffer_t *))A.buffer)
let A.dimensions = _halide_buffer_get_dimensions(((buffer_t *))A.buffer)
let A.min.0 = _halide_buffer_get_min(((buffer_t *))A.buffer, 0)
let A.extent.0 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 0)
let A.stride.0 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 0)
let A.min.1 = _halide_buffer_get_min(((buffer_t *))A.buffer, 1)
let A.extent.1 = _halide_buffer_get_extent(((buffer_t *))A.buffer, 1)
let A.stride.1 = _halide_buffer_get_stride(((buffer_t *))A.buffer, 1)
let B = ((void *))_halide_buffer_get_host(((buffer_t *))B.buffer)
let B.type = (uint32)_halide_buffer_get_type(((buffer_t *))B.buffer)
let B.dimensions = _halide_buffer_get_dimensions(((buffer_t *))B.buffer)
let B.min.0 = _halide_buffer_get_min(((buffer_t *))B.buffer, 0)
let B.extent.0 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 0)
let B.stride.0 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 0)
let B.min.1 = _halide_buffer_get_min(((buffer_t *))B.buffer, 1)
let B.extent.1 = _halide_buffer_get_extent(((buffer_t *))B.buffer, 1)
let B.stride.1 = _halide_buffer_get_stride(((buffer_t *))B.buffer, 1)
let Out = ((void *))_halide_buffer_get_host(((buffer_t *))Out.buffer)
let Out.type = (uint32)_halide_buffer_get_type(((buffer_t *))Out.buffer)
let Out.dimensions = _halide_buffer_get_dimensions(((buffer_t *))Out.buffer)
let Out.min.0 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 0)
let Out.extent.0 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 0)
let Out.stride.0 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 0)
let Out.min.1 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 1)
let Out.extent.1 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 1)
let Out.stride.1 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 1)
let Out.min.2 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 2)
let Out.extent.2 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 2)
let Out.stride.2 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 2)
let Out.min.3 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 3)
let Out.extent.3 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 3)
let Out.stride.3 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 3)
let Out.min.4 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 4)
let Out.extent.4 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 4)
let Out.stride.4 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 4)
let Out.min.5 = _halide_buffer_get_min(((buffer_t *))Out.buffer, 5)
let Out.extent.5 = _halide_buffer_get_extent(((buffer_t *))Out.buffer, 5)
let Out.stride.5 = _halide_buffer_get_stride(((buffer_t *))Out.buffer, 5)
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))A.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))A.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))A.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(A.min.0, A.extent.0, 1, 0, A.min.1, A.extent.1, A.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))B.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))B.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))B.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 2, ((halide_dimension_t *))make_struct(B.min.0, B.extent.0, 1, 0, B.min.1, B.extent.1, B.extent.0, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query(((buffer_t *))Out.buffer)) {
 ((halide_buffer_t *))_halide_buffer_init(((halide_buffer_t *))Out.buffer, ((halide_dimension_t *))_halide_buffer_get_shape(((halide_buffer_t *))Out.buffer), ((void *))reinterpret((uint64)0), (uint64)0, ((halide_device_interface_t *))reinterpret((uint64)0), 2, 32, 6, ((halide_dimension_t *))make_struct(0, 8, 1, 0, 0, 32, 8, 0, 0, 8, 256, 0, 0, 2, 2048, 0, 0, (B.extent.0/64), 4096, 0, 0, (A.extent.1/64), ((B.extent.0/64)*4096), 0), (uint64)0)
}
assert((A.type == (uint32)73730), halide_error_bad_type("Input buffer A", A.type, (uint32)73730))
assert((A.dimensions == 2), halide_error_bad_dimensions("Input buffer A", A.dimensions, 2))
assert((B.type == (uint32)73730), halide_error_bad_type("Input buffer B", B.type, (uint32)73730))
assert((B.dimensions == 2), halide_error_bad_dimensions("Input buffer B", B.dimensions, 2))
assert((Out.type == (uint32)73730), halide_error_bad_type("Output buffer Out", Out.type, (uint32)73730))
assert((Out.dimensions == 6), halide_error_bad_dimensions("Output buffer Out", Out.dimensions, 6))
assert((0 <= A.extent.0), halide_error_buffer_extents_negative("Input buffer A", 0, A.extent.0))
assert((0 <= A.extent.1), halide_error_buffer_extents_negative("Input buffer A", 1, A.extent.1))
assert((0 <= B.extent.0), halide_error_buffer_extents_negative("Input buffer B", 0, B.extent.0))
assert((0 <= B.extent.1), halide_error_buffer_extents_negative("Input buffer B", 1, B.extent.1))
assert(((Out.min.0 <= 0) && (8 <= (Out.extent.0 + Out.min.0))), halide_error_access_out_of_bounds("Output buffer Out", 0, 0, 7, Out.min.0, ((Out.extent.0 + Out.min.0) + -1)))
assert((0 <= Out.extent.0), halide_error_buffer_extents_negative("Output buffer Out", 0, Out.extent.0))
assert(((Out.min.1 <= 0) && (32 <= (Out.extent.1 + Out.min.1))), halide_error_access_out_of_bounds("Output buffer Out", 1, 0, 31, Out.min.1, ((Out.extent.1 + Out.min.1) + -1)))
assert((0 <= Out.extent.1), halide_error_buffer_extents_negative("Output buffer Out", 1, Out.extent.1))
assert(((Out.min.2 <= 0) && (8 <= (Out.extent.2 + Out.min.2))), halide_error_access_out_of_bounds("Output buffer Out", 2, 0, 7, Out.min.2, ((Out.extent.2 + Out.min.2) + -1)))
assert((0 <= Out.extent.2), halide_error_buffer_extents_negative("Output buffer Out", 2, Out.extent.2))
assert(((Out.min.3 <= 0) && (2 <= (Out.extent.3 + Out.min.3))), halide_error_access_out_of_bounds("Output buffer Out", 3, 0, 1, Out.min.3, ((Out.extent.3 + Out.min.3) + -1)))
assert((0 <= Out.extent.3), halide_error_buffer_extents_negative("Output buffer Out", 3, Out.extent.3))
assert(((Out.min.4 <= 0) && ((B.extent.0/64) <= (Out.extent.4 + Out.min.4))), halide_error_access_out_of_bounds("Output buffer Out", 4, 0, ((B.extent.0/64) + -1), Out.min.4, ((Out.extent.4 + Out.min.4) + -1)))
assert((0 <= Out.extent.4), halide_error_buffer_extents_negative("Output buffer Out", 4, Out.extent.4))
assert(((Out.min.5 <= 0) && ((A.extent.1/64) <= (Out.extent.5 + Out.min.5))), halide_error_access_out_of_bounds("Output buffer Out", 5, 0, ((A.extent.1/64) + -1), Out.min.5, ((Out.extent.5 + Out.min.5) + -1)))
assert((0 <= Out.extent.5), halide_error_buffer_extents_negative("Output buffer Out", 5, Out.extent.5))
assert((A.stride.0 == 1), halide_error_constraint_violated("A.stride.0", A.stride.0, "1", 1))
assert((B.stride.0 == 1), halide_error_constraint_violated("B.stride.0", B.stride.0, "1", 1))
assert((Out.stride.0 == 1), halide_error_constraint_violated("Out.stride.0", Out.stride.0, "1", 1))
let A.total_extent.1 = (int64(A.extent.1)*int64(A.extent.0))
let B.total_extent.1 = (int64(B.extent.1)*int64(B.extent.0))
let Out.total_extent.1 = (int64(Out.extent.1)*int64(Out.extent.0))
let Out.total_extent.2 = (Out.total_extent.1*int64(Out.extent.2))
let Out.total_extent.3 = (Out.total_extent.2*int64(Out.extent.3))
let Out.total_extent.4 = (Out.total_extent.3*int64(Out.extent.4))
let Out.total_extent.5 = (Out.total_extent.4*int64(Out.extent.5))
assert(((uint64)abs(int64(A.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs(int64(A.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(A.extent.1)*int64(A.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("A", (uint64)abs((int64(A.extent.1)*int64(A.stride.1))), (uint64)2147483647))
assert((A.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("A", A.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(B.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs(int64(B.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(B.extent.1)*int64(B.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("B", (uint64)abs((int64(B.extent.1)*int64(B.stride.1))), (uint64)2147483647))
assert((B.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("B", B.total_extent.1, (int64)2147483647))
assert(((uint64)abs(int64(Out.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs(int64(Out.extent.0)), (uint64)2147483647))
assert(((uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.1)*int64(Out.stride.1))), (uint64)2147483647))
assert((Out.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.1, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.2)*int64(Out.stride.2))), (uint64)2147483647))
assert((Out.total_extent.2 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.2, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.3)*int64(Out.stride.3))), (uint64)2147483647))
assert((Out.total_extent.3 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.3, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.4)*int64(Out.stride.4))), (uint64)2147483647))
assert((Out.total_extent.4 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.4, (int64)2147483647))
assert(((uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("Out", (uint64)abs((int64(Out.extent.5)*int64(Out.stride.5))), (uint64)2147483647))
assert((Out.total_extent.5 <= (int64)2147483647), halide_error_buffer_extents_too_large("Out", Out.total_extent.5, (int64)2147483647))
gpu_block<CM> (X.s0.i.__block_id_y, 0, (A.extent.1/64)) {
 gpu_block<CM> (X.s0.j.__block_id_x, 0, (B.extent.0/64)) {
  gpu_thread<CM> (.__thread_id_y, 0, 2) {
   gpu_thread<CM> (.__thread_id_x, 0, 8) {
    allocate Z[float32 * 256]
    allocate A_im_buf[float32 * 256] in Register
    allocate B_im_buf[float32 * 64] in Register
    Z[ramp(0, 1, 256)] = x256(0.000000f)
    for (X.s0.k, 0, (A.extent.0/8)) {
     let var.B_im.load.addr.1 = (X.s0.k*8)
     let var.B_im.load.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
     (float32)cm_load_2d(B, var.B_im.load.addr.0, var.B_im.load.addr.1, B_im_buf, ramp(0, 1, 64), 8, 8)
     let var.A_im.load.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
     let var.A_im.load.addr.0 = (X.s0.k*8)
     (float32)cm_load_2d(A, var.A_im.load.addr.0, var.A_im.load.addr.1, A_im_buf, ramp(0, 1, 256), 8, 32)
     punrolled (X.s0.iii, 0, 32) {
      punrolled (X.s0.kkk, 0, 8) {
       Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] = (Z[ramp((X.s0.iii*8), 1, 8) aligned(8, 0)] + (B_im_buf[ramp((X.s0.kkk*8), 1, 8) aligned(8, 0)]*x8(A_im_buf[((X.s0.iii*8) + X.s0.kkk)])))
      }
     }
    }
    free A_im_buf
    free B_im_buf
    let var.Out.store.addr.1 = (((X.s0.i.__block_id_y*2) + .__thread_id_y)*32)
    let var.Out.store.addr.0 = (((X.s0.j.__block_id_x*8) + .__thread_id_x)*8)
    (float32x256)cm_store_2d(Out, var.Out.store.addr.0, var.Out.store.addr.1, Z, ramp(0, 1, 256), 8, 32, "C")
    free Z
   }
  }
 }
}

Module.compile(): dev_src gemm
Constructing CM device codegen
CM device codegen init_module
Generating llvm bitcode prolog for function gemm...
Generating llvm bitcode for function gemm...
Kernel launch: X.s0.i.__block_id_y
Kernel bounds: (8, 2, 1, 1) threads, ((B.extent.0/64), (A.extent.1/64), 1, 1) blocks
var: A
var: A.extent.0
var: B
var: Out
buffer: A 0 (read)
buffer: B 0 (read)
buffer: Out 0 (write)
CodeGen_CM_Dev::compile kernel_X
Adding CM kernel kernel_X
Compiled launch to kernel "kernel_X"
Currently, we do not implement CM runtime.
Generating init_kernels for cm
CM kernel:
#include <cm/cm.h>
#include <cm/cmtl.h>
extern "C" _GENX_MAIN_ void kernel_X(
int _A_extent_0,
SurfaceIndex _A [[type("image2d_t float")]],
SurfaceIndex _B [[type("image2d_t float")]],
SurfaceIndex _C [[type("image2d_t float")]])
{
  int _X_s0_i___block_id_y = cm_group_id(1);
  int _X_s0_j___block_id_x = cm_group_id(0);
  int ___thread_id_y = cm_local_id(1);
  int ___thread_id_x = cm_local_id(0);
  vector<float, 256> _Z;
  vector<float, 256> _A_im_buf;
  vector<float, 64> _B_im_buf;
  _Z.select<256, 1>(0) = 0.000000f;
  for (int _X_s0_k = 0; _X_s0_k < 0 + (_A_extent_0/8); _X_s0_k++)
  {
    int _54 = (_X_s0_k*8);
    int _55 = (((_X_s0_j___block_id_x*8)+___thread_id_x)*8);
    read(_B, (_55*4), (_54+0), _B_im_buf.select<64, 1>(0).format<float, 8, 8>().select<8, 1, 8, 1>(0, 0));
    int _56 = (((_X_s0_i___block_id_y*2)+___thread_id_y)*32);
    int _57 = (_X_s0_k*8);
    read(_A, (_57*4), (_56+0), _A_im_buf.select<256, 1>(0).format<float, 32, 8>().select<8, 1, 8, 1>(0, 0));
    read(_A, (_57*4), (_56+8), _A_im_buf.select<256, 1>(0).format<float, 32, 8>().select<8, 1, 8, 1>(8, 0));
    read(_A, (_57*4), (_56+16), _A_im_buf.select<256, 1>(0).format<float, 32, 8>().select<8, 1, 8, 1>(16, 0));
    read(_A, (_57*4), (_56+24), _A_im_buf.select<256, 1>(0).format<float, 32, 8>().select<8, 1, 8, 1>(24, 0));
    #pragma unroll
    for (int _X_s0_iii = 0; _X_s0_iii < 0 + 32; _X_s0_iii++)
    {
      #pragma unroll
      for (int _X_s0_kkk = 0; _X_s0_kkk < 0 + 8; _X_s0_kkk++)
      {
        _Z.select<8, 1>((_X_s0_iii*8)) = (_Z.select<8, 1>((_X_s0_iii*8))+(_B_im_buf.select<8, 1>((_X_s0_kkk*8))*_A_im_buf(((_X_s0_iii*8)+_X_s0_kkk))));
      } // for _X_s0_kkk
    } // for _X_s0_iii
  } // for _X_s0_k
  int _58 = (((_X_s0_i___block_id_y*2)+___thread_id_y)*32);
  int _59 = (((_X_s0_j___block_id_x*8)+___thread_id_x)*8);
  write(_C, (_59*4), (_58+0), _Z.select<256, 1>(0).format<float, 32, 8>().select<8, 1, 8, 1>(0, 0));
  write(_C, (_59*4), (_58+8), _Z.select<256, 1>(0).format<float, 32, 8>().select<8, 1, 8, 1>(8, 0));
  write(_C, (_59*4), (_58+16), _Z.select<256, 1>(0).format<float, 32, 8>().select<8, 1, 8, 1>(16, 0));
  write(_C, (_59*4), (_58+24), _Z.select<256, 1>(0).format<float, 32, 8>().select<8, 1, 8, 1>(24, 0));
} // kernel kernel_X

Currently, we do not implement CM runtime, so we just emit source code.
Success
