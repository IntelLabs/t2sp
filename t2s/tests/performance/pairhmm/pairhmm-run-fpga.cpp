// The header file generated by pairhmm.cpp
#include "pairhmm-interface.h"

// Constant parameters (inner loop bounds) of the design
#include "const-parameters.h"

// Roofline Utilities
#include "Roofline.h"

// The only header file needed for including T2S.
#include "HalideBuffer.h"

// For printing output
#include <stdio.h>
#include <iostream>

// For validation of results.
#include <assert.h>

using namespace std;

template<size_t N1, size_t N2>
Halide::Runtime::Buffer<unsigned char> new_characters() {
    Halide::Runtime::Buffer<unsigned char> b(N1, N2);
    srand(time(0));
    for (size_t i = 0; i < N1; i++) {
        for (size_t j = 0; j < N2; j++) {
            b(i, j) = 'A' + (rand() % 26);
        }
    }
    return b;
}

template<typename T, size_t N1, size_t N2>
Halide::Runtime::Buffer<T> new_probability() {
    Halide::Runtime::Buffer<T> b(N1, N2);
    srand(time(0));
    for (size_t i = 0; i < N1; i++) {
        for (size_t j = 0; j < N2; j++) {
            b(i, j) = (T) (((T)(rand() * 1.0)) / ((T)(RAND_MAX * 1.0)));
        }
    }
    return b;
}

int main()
{
    // Generate random input numbers
    Halide::Runtime::Buffer<unsigned char> H = new_characters<HAP_LEN, NUM_HAPS>();
    Halide::Runtime::Buffer<unsigned char> R = new_characters<READ_LEN, NUM_READS>();
    Halide::Runtime::Buffer<float> Q = new_probability<float, READ_LEN, NUM_READS>();
    Halide::Runtime::Buffer<float> alpha = new_probability<float, READ_LEN, NUM_READS>();
    Halide::Runtime::Buffer<float> delta = new_probability<float, READ_LEN, NUM_READS>();
    Halide::Runtime::Buffer<float> zeta = new_probability<float, READ_LEN, NUM_READS>();
    // Pre-compute some input numbers
    Halide::Runtime::Buffer<float> eta(READ_LEN, NUM_READS);
    Halide::Runtime::Buffer<float> alpha_match(READ_LEN, NUM_READS);
    Halide::Runtime::Buffer<float> alpha_gap(READ_LEN, NUM_READS);
    Halide::Runtime::Buffer<float> beta_match(READ_LEN, NUM_READS);
    Halide::Runtime::Buffer<float> beta_gap(READ_LEN, NUM_READS);

    int beta_val = 0.9f;
    int eta_val = 0.1f;
    for (size_t i = 0; i < NUM_READS; i++) {
        for (size_t j = 0; j < READ_LEN; j++) {
            alpha_match(j, i) = (1.0f - Q(j, i)) * alpha(j, i);
            alpha_gap(j, i) = (Q(j, i) / 3) * alpha(j, i);
            beta_match(j, i) = (1.0f - Q(j, i)) * beta_val;
            beta_gap(j, i) = (Q(j, i) / 3) * beta_val;
            eta(j, i) = eta_val;
        }
    }

    Halide::Runtime::Buffer<float> result(RR, HH, OR, OH);
    pairhmm(H, R, delta, zeta, eta, alpha_match, alpha_gap, beta_match, beta_gap, result);

#ifdef TINY
    // Validate the results
    for (int h = 0; h < OH; h++)
    for (int r = 0; r < OR; r++)
    for (int hh = 0; hh < HH; hh++)
    for (int rr = 0; rr < RR; rr++) {
        int total_r = r * RR + rr;
        int total_h = h * HH + hh;
        float golden = 0.0;
        Halide::Runtime::Buffer<float> M(READ_LEN, HAP_LEN);
        Halide::Runtime::Buffer<float> I(READ_LEN, HAP_LEN);
        Halide::Runtime::Buffer<float> D(READ_LEN, HAP_LEN);
        for (int j = 0; j < HAP_LEN; j++) {
            for (int i = 0; i < READ_LEN; i++) {
                if (j == 0) {
                    M(i, 0) = 0.0;
                    I(i, 0) = 0.0;
                    D(i, 0) = 0.0;
                }
                if (i == 0) {
                    M(0, j) = 0.0;
                    I(0, j) = 0.0;
                    D(0, j) = 1.0 / (HAP_LEN - 1);
                }
                if (j != 0 && i != 0) {
                    float alpha = (R(i, total_r) == H(j, total_h)) ? alpha_match(i, total_r) : alpha_gap(i, total_r);
                    float beta  = (R(i, total_r) == H(j, total_h)) ? beta_match(i, total_r) : beta_gap(i, total_r);
                    M(i, j) = alpha * M(i - 1, j - 1) +  beta * (I(i - 1, j - 1) + D(i - 1, j - 1));
                    I(i, j) = delta(i, total_r) * M(i - 1, j) + eta(i, total_r) * I(i - 1, j);
                    D(i, j) = zeta(i, total_r) * M(i, j - 1) + eta(i, total_r) * D(i, j - 1);
                }
                if (i == READ_LEN - 1 && j > 0) {
                    golden += M(READ_LEN-1, j) + I(READ_LEN-1, j);
                }
                assert(abs(golden - result(rr, hh, r, h)) < 1e-6);
            }
        }
    }
#else
    double exec_time = ExecTime();
    double number_ops = NUM_READS * READ_LEN * NUM_HAPS * HAP_LEN;
    cout << "Length of read strings: " << NUM_READS << "*" << READ_LEN << "\n";
    cout << "Length of hap strings: " << NUM_HAPS << "*" << HAP_LEN << "\n";
    cout << "GCups: " << number_ops / exec_time << "\n";
#endif

    printf("Success\n");
    return 0;
}
