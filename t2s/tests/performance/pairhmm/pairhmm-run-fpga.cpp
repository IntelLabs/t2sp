// The header file generated by pairhmm.cpp
#include "pairhmm-interface.h"

// Constant parameters (inner loop bounds) of the design
#include "const-parameters.h"

// Outer loop bounds for testing
#ifdef TINY // For verifying correctness only
    #define OR      4
    #define OH      4
#else
    #define OR      16
    #define OH      16
#endif

#define NUM_READS   (OR*RR)
#define NUM_HAPS    (OH*HH)

// Roofline Utilities
#include "Roofline.h"

// The only header file needed for including T2S.
#include "HalideBuffer.h"

// For printing output
#include <stdio.h>
#include <iostream>

// For validation of results.
#include <assert.h>
#include "context.h"

using namespace std;

template<size_t N1, size_t N2>
Halide::Runtime::Buffer<unsigned char> new_characters() {
    Halide::Runtime::Buffer<unsigned char> b(N1, N2);
    for (size_t i = 0; i < N1; i++) {
        for (size_t j = 0; j < N2; j++) {
            b(i, j) = 'A' + (rand() % 26);
        }
    }
    return b;
}

// T can only be float or double here
template<size_t N1, size_t N2>
Halide::Runtime::Buffer<float> new_probability() {
    Halide::Runtime::Buffer<float> b(N1, N2);
    for (size_t i = 0; i < N1; i++) {
        for (size_t j = 0; j < N2; j++) {
            b(i, j) = (float)(rand() * 1.0) / (float)(RAND_MAX * 1.0);
        }
    }
    return b;
}

Halide::Runtime::Buffer<unsigned char> H(NUM_HAPS, HAP_LEN), R(READ_LEN, NUM_READS);
Halide::Runtime::Buffer<float> delta(READ_LEN, NUM_READS), zeta(READ_LEN, NUM_READS), eta(READ_LEN, NUM_READS);
Halide::Runtime::Buffer<float> alpha_match(READ_LEN, NUM_READS), alpha_gap(READ_LEN, NUM_READS);
Halide::Runtime::Buffer<float> beta_match(READ_LEN, NUM_READS), beta_gap(READ_LEN, NUM_READS);

void set_pseudo_input()
{
    // Generate random input string
    H = new_characters<NUM_HAPS, HAP_LEN>();
    R = new_characters<READ_LEN, NUM_READS>();
    delta = new_probability<READ_LEN, NUM_READS>();
    zeta = new_probability<READ_LEN, NUM_READS>();
    eta = new_probability<READ_LEN, NUM_READS>();

    for (size_t i = 0; i < NUM_READS; i++) {
        for (size_t j = 0; j < READ_LEN; j++) {
            float Q = (float)(rand() * 1.0) / (float)(RAND_MAX * 1.0);
            float alpha = (float)(rand() * 1.0) / (float)(RAND_MAX * 1.0);
            float beta = (float)(rand() * 1.0) / (float)(RAND_MAX * 1.0);
            alpha_match(j, i) = (1.0f - Q) * alpha;
            alpha_gap(j, i) = (Q / 3) * alpha;
            beta_match(j, i) = (1.0f - Q) * beta;
            beta_gap(j, i) = (Q / 3) * beta;
        }
    }
}

void set_real_input()
{
    // Generate random input string
    H = new_characters<NUM_HAPS, NUM_HAPS>();
    R = new_characters<READ_LEN, NUM_READS>();
    Halide::Runtime::Buffer<unsigned char> R_c = new_characters<READ_LEN, NUM_READS>();
    Halide::Runtime::Buffer<unsigned char> R_i = new_characters<READ_LEN, NUM_READS>();
    Halide::Runtime::Buffer<unsigned char> R_d = new_characters<READ_LEN, NUM_READS>();
    Halide::Runtime::Buffer<unsigned char> R_q =  new_characters<READ_LEN, NUM_READS>();

    Context<float> ctx;
    for (size_t i = 0; i < NUM_READS; i++) {
        for (size_t j = 0; j < READ_LEN; j++) {
            float alpha = ctx.set_mm_prob(R_i(j, i), R_d(j, i));
            float beta  = 1.0f - ctx.ph2pr[R_c(j, i)];
            delta(j, i) = ctx.ph2pr[R_i(j, i)];
            zeta(j, i)  = ctx.ph2pr[R_d(j, i)];
            eta(j, i)   = ctx.ph2pr[R_c(j, i)];
            alpha_match(j, i) = alpha * (1.0f - ctx.ph2pr[R_q(j, i)]);
            alpha_gap(j, i)   = alpha * ctx.ph2pr[R_q(j, i)] / 3.0f;
            beta_match(j, i)  = beta * (1.0f - ctx.ph2pr[R_q(j, i)]);
            beta_gap(j, i)    = beta * ctx.ph2pr[R_q(j, i)] / 3.0f;
        }
    }
}

int main()
{
    set_real_input();
    Halide::Runtime::Buffer<float> result(HH, RR, OH, OR);
    pairhmm(H, R, delta, zeta, eta, alpha_match, alpha_gap, beta_match, beta_gap, result);

#ifdef TINY
    // Validate the results
    for (int h = 0; h < OH; h++)
    for (int r = 0; r < OR; r++)
    for (int hh = 0; hh < HH; hh++)
    for (int rr = 0; rr < RR; rr++) {
        int total_r = r * RR + rr;
        int total_h = h * HH + hh;
        float golden = 0.0;
        Halide::Runtime::Buffer<float> M(READ_LEN, HAP_LEN);
        Halide::Runtime::Buffer<float> I(READ_LEN, HAP_LEN);
        Halide::Runtime::Buffer<float> D(READ_LEN, HAP_LEN);
        for (int j = 0; j < HAP_LEN; j++) {
            for (int i = 0; i < READ_LEN; i++) {
                if (j == 0) {
                    M(i, 0) = 0.0;
                    I(i, 0) = 0.0;
                    D(i, 0) = 0.0;
                }
                if (i == 0) {
                    M(0, j) = 0.0;
                    I(0, j) = 0.0;
                    D(0, j) = 1.0 / (HAP_LEN - 1);
                }
                if (j != 0 && i != 0) {
                    float alpha = (R(i, total_r) == H(total_h, j)) ? alpha_match(i, total_r) : alpha_gap(i, total_r);
                    float beta  = (R(i, total_r) == H(total_h, j)) ? beta_match(i, total_r) : beta_gap(i, total_r);
                    M(i, j) = alpha * M(i - 1, j - 1) +  beta * (I(i - 1, j - 1) + D(i - 1, j - 1));
                    I(i, j) = delta(i, total_r) * M(i - 1, j) + eta(i, total_r) * I(i - 1, j);
                    D(i, j) = zeta(i, total_r) * M(i, j - 1) + eta(i, total_r) * D(i, j - 1);
                }
                if (i == READ_LEN - 1 && j > 0) {
                    golden += M(READ_LEN-1, j) + I(READ_LEN-1, j);
                }
            }
        }
        assert(abs(golden - result(hh, rr, h, r)) < 1e-6);
    }
#else
    double exec_time = ExecTime();
    double number_ops = (double)NUM_READS * READ_LEN * NUM_HAPS * HAP_LEN;
    cout << "Length of read strings: " << NUM_READS << "*" << READ_LEN << "\n";
    cout << "Length of hap strings: " << NUM_HAPS << "*" << HAP_LEN << "\n";
    cout << "GCups: " << number_ops / exec_time << "\n";
#endif

    printf("Success\n");
    return 0;
}
