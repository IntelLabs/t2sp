/*******************************************************************************
* Copyright 2021 Intel Corporation
*
* Licensed under the BSD-2-Clause Plus Patent License (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* https://opensource.org/licenses/BSDplusPatent
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions
* and limitations under the License.
*
*
* SPDX-License-Identifier: BSD-2-Clause-Patent
*******************************************************************************/
// The only header file needed for including T2S.
#include "HalideBuffer.h"

// The header file generated by gemm.cpp
#include "conv-interface.h"

// Roofline utilities
#include "Roofline.h"

// For printing output
#include <stdio.h>
#include <iostream>

// For validation of results.
#include <assert.h>

// Constant parameters (inner loop bounds) of the design
#include "const-parameters.h"

// Outer loop bounds for testing
#ifdef TINY // For verifying correctness only
    #define N       4
#else
    #define N       64
#endif

using namespace std;

int main()
{
    Halide::Runtime::Buffer<float> i(TOTAL_IY, TOTAL_IX, TOTAL_CI, N), k(KY, KX, TOTAL_CI, TOTAL_CO);
    for (size_t n = 0; n < N; n++) {
        for (size_t ci = 0; ci < TOTAL_CI; ci++) {
            for (size_t x = 0; x < TOTAL_IX; x++) {
                for (size_t y = 0; y < TOTAL_IY; y++) {
                    i(y, x, ci, n) = random();
                }
            }
        }
    }
    for (size_t co = 0; co < TOTAL_CO; co++) {
        for (size_t ci = 0; ci < TOTAL_CI; ci++) {
            for (size_t kx = 0; kx < KX; kx++) {
                for (size_t ky = 0; ky < KY; ky++) {
                    k(ky, kx, ci, co) = random();
                }
            }
        }
    }
    Halide::Runtime::Buffer<float> o(COO, YY, XXP, COP, Y, X, YP, XP, XX, CO, N);
    CONV(i, k, o);

#ifdef TINY
    // Validate the results
    for (int n = 0; n < N; n++)
    for (int co = 0; co < CO; co++)
    for (int xx = 0; xx < XX; xx++)
    for (int xp = 0; xp < XP; xp++)
    for (int yp = 0; yp < YP; yp++)
    for (int x = 0; x < X; x++)
    for (int y = 0; y < Y; y++)
    for (int cop = 0; cop < COP; cop++)
    for (int xxp = 0; xxp < XXP; xxp++)
    for (int yy = 0; yy < YY; yy++)
    for (int coo = 0; coo < COO; coo++) {
        float golden = 0.0f;
        for (int ci = 0; ci < TOTAL_CI; ci++)
        for (int kx = 0; kx < KX; kx++)
        for (int ky = 0; ky < KY; ky++) {
            size_t total_iy = (yy  + YY*y  + YY*Y*yp  + ky);
            size_t total_ix = (xxp + XXP*x + XXP*X*xp + XXP*X*XP*xx + kx);
            size_t total_co = (coo + COO*cop + COO*COP*co);
            golden += i(total_iy, total_ix, ci, n) * k(ky, kx, ci, total_co);
        }
        assert(fabs(golden - o(coo, yy, xxp, cop, y, x, yp, xp, xx, co, n)) < 0.005*fabs(golden));
    }
#else
    // Report performance. DSPs, FMax and ExecTime are automatically figured out from the static analysis
    // during FPGA synthesis and and the dynamic profile during the FGPA execution.
    // A10PAC on DevCloud has 33GB/s memory bandwidth
    double mem_bandwidth = 33;
    double compute_roof = 2 * DSPs() * FMax();
     // Total operations (GFLOP for CONV), independent of designs
    double number_ops = 2 * (long)(N * XP * YP) * (long)(TOTAL_CO * XXP * YY) * (long)(TOTAL_CI * KX * KY);
    double number_bytes = (long)(TOTAL_IY * TOTAL_IX * TOTAL_CI * N) * 4 + (long)(KY * KX * TOTAL_CI * TOTAL_CO) * 4
                        + (long)(TOTAL_OY * TOTAL_OX * TOTAL_CO * N) * 4;
    double exec_time = ExecTime();
    roofline(mem_bandwidth, compute_roof, number_ops, number_bytes, exec_time);
    if (fopen("roofline.png", "r") == NULL) {
        cout << "Failed to draw roofline!\n";
        return 1;
    }
#endif

    printf("Success\n");
    return 0;
}
