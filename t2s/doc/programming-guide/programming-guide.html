<h1 data-number="1" id="overview"><span class="header-section-number">1</span> Overview</h1>
<p>T2SP generates accelerators for dense tensor computes. Usually, such a compute is described as one or a few math equations. We can rewrite these equations to be recursive, the so-called Uniform Recursive Equations or UREs. With UREs, we can accurately control input and output data to flow in a pipeline fashion during the compute.</p>
<p>We can write basic UREs without tiling the compute domain. Then we tile the compute domain for data locality and reuse. It is straightforward to translate basic UREs into the final UREs after tiling.</p>
<p>Note that UREs are simply C statements. So after adding some helper code necessary for testing, we can compile them in any C compiler, print out the results, and check if the UREs are correct vs. the original math equations.</p>
<p>The compute domain is iterated with a loop nest. If the compute is to run on a GPU, we need decide which loops are block loops, and inside a block, which loops are thread loops: An iteration of the thread loops will be turned into a thread. If the compute is to run on an FPGA, however, we always use a single thread for the entire compute, and thus there is no block and thread loops.</p>
<p>Inside a thread, we will build a systolic array in a space-time transform. So we need decide which loops are space loops.</p>
<p>Finally, we add an I/O network for the systolic array. The I/O network is composed of multiple memory levels. The input/output data are loaded/unloaded through the I/O network into/out of the systolic array. Inside the systolic array, the data flow according to the UREs.</p>
<p>Now for the original compute, we have a complete T2SP program, or more accurately, a specification, since such a program only specifies what to implement (e.g. space-time transform and I/O network), but leave the actual implementation to the T2SP compiler. In other words, the program controls the compiler to generate the expected accelerator.</p>
<p>For an FPGA, the T2SP compiler generates OpenCL device code and a C interface, compile and run these generated code by invoking the downstream FPGA tools. The programmer can use the emulator tool to verify correctness of the generated code, and use the synthesis tool to produce a bit-stream. The programmer can write CPU host code and call the device code through the C interface, just like calling any normal C function on a CPU. That call would offload the compute to the emulator or an actual FPGA to run.</p>
<p>For a GPU, the T2SP compiler generates CM device code, and invoke the CM compiler to build a binary. The programmer need write CPU host code that offloads the device code to a GPU.</p>
<p>A beginner might encounter several hurdles in using T2SP: (1) how to write UREs? (2) how to tile loops? (3) how to decide block, thread, and space loops? and (4) how to design I/O? There are numerous valid answers for each of these questions. Fortunately, we do not have to be mathematicians, algorithm experts, or computer architects in order to effectively address the questions. Based on simple and intuitive rules, any programmer may master the programming quickly, and use the skills to accelerate real-world workloads.</p>
<p>We will describe the steps in more details below.</p>
<p><img src="./img/overall-flow.png" title="Overall flow" id="id" class="class" width="700" /></p>
<h1 data-number="2" id="rewriting-math-equations-into-basic-ures"><span class="header-section-number">2</span> Rewriting math equations into basic UREs</h1>
<p>Based on the work of Gusev and Evans <a href="#1">[1]</a><a href="#2">[2]</a>, we can translate math equations into UREs, following the simple steps below. Going through an example, we would find that this process is pretty much mechanical and intuitive, and only middle-school level of math knowledge is needed. So do not be scared by the math symbols. We strongly recommend a beginner repeats the steps of an example, during which the beginner would quickly master the skills. These skills are applicable to other real world problems, not limited to the examples here.</p>
<p>Use auto-regressive filter for example:</p>
<figure>
<img src="./img/deriving-ures-for-auto-regressive-filter.png" id="Fig:deriving-ures-for-auto-regressive-filter" alt="Deriving ures" /><figcaption aria-hidden="true">Deriving ures</figcaption>
</figure>
<p>figure is here {Fig. <strong>¿fig:deriving-ures-for-auto-regressive-filter?</strong>}</p>
<p><img src="./img/deriving-ures-for-auto-regressive-filter.png" id="tbl:deriving-ures-for-auto-regressive-filter" /></p>
<h2 data-number="2.1" id="step-1-iterative-form"><span class="header-section-number">2.1</span> Step 1: Iterative form</h2>
<p>First, write down the math equations of the original problem. Usually, these equations are to iterate over a domain (like <span class="math inline"><em>j</em> = 1, ..., <em>n</em></span>) and compute some variables (like <span class="math inline"><em>y</em><sub><em>i</em></sub></span>).</p>
<p>table tbl. <strong>¿tbl:deriving-ures-for-auto-regressive-filter?</strong> is here</p>
<h2 data-number="2.2" id="step-2-recursive-form"><span class="header-section-number">2.2</span> Step 2: Recursive form</h2>
<p>Translate the iterative form to recursive form is straightforward: figure out the initial value of a variable (e.g. <span class="math inline"><em>y</em><sub><em>i</em></sub> = <em>x</em><sub><em>i</em></sub></span>), and update the variable every iteration with a new value based on its previous value (e.g. <span class="math inline"><em>y</em><sub><em>i</em></sub> = <em>y</em><sub><em>i</em></sub> + ...</span>).</p>
<h2 data-number="2.3" id="step-3-dsa-dynamic-single-assignment"><span class="header-section-number">2.3</span> Step 3: DSA (Dynamic Single Assignment)</h2>
<p>Every iteration, assign a variable to a distinct memory location. Every writing to a variable (and correspondingly, every reading of the variable) are indicated by the iteration index. For example, in iteration <span class="math inline"><em>j</em></span>, <span class="math inline"><em>y</em><sub><em>i</em></sub> = <em>y</em><sub><em>i</em></sub> + ...<em>y</em><sub><em>i</em> − <em>j</em></sub></span> is changed into <span class="math inline"><em>y</em><sub><em>i</em></sub><sup><em>j</em></sup> = <em>y</em><sub><em>i</em></sub><sup><em>j</em> − 1</sup> + ...<em>y</em><sub><em>i</em> − <em>j</em></sub><sup><em>n</em></sup></span>. After such renaming, the iterations where <span class="math inline"><em>y</em></span> are assigned values are clearly exposed. Consequently, the dependences between these iterations are made explicit.</p>
<p>For another example, the initial condition <span class="math inline"><em>y</em><sub><em>i</em></sub> = <em>x</em><sub><em>i</em></sub></span> is changed into <span class="math inline"><em>y</em><sub><em>i</em></sub><sup>0</sup> = <em>x</em><sub><em>i</em></sub></span>: iteration index <span class="math inline"><em>j</em></span> starts from 1 in this example, and therefore, <span class="math inline"><em>y</em><sub><em>i</em></sub><sup>0</sup></span> is the <span class="math inline"><em>y</em><sub><em>i</em></sub></span> before iteration <span class="math inline"><em>j</em></span> starts. In general, if iteration index <span class="math inline"><em>j</em></span> starts from <span class="math inline"><em>s</em></span> and has a step <span class="math inline"><em>h</em></span>, the initial condition should be <span class="math inline"><em>y</em><sub><em>i</em></sub><sup><em>s</em> − <em>h</em></sup> = ...</span>.</p>
<h2 data-number="2.4" id="step-4-full-index-form"><span class="header-section-number">2.4</span> Step 4: Full index form</h2>
<p>Now variables are referenced with full indices, but constants are not: <span class="math inline"><em>c</em><sub><em>j</em></sub></span> and <span class="math inline"><em>x</em><sub><em>i</em></sub></span> are input values, never modified during the iterations. Give them full indices as well by adding 0’s: <span class="math inline"><em>c</em><sub><em>j</em></sub></span> and <span class="math inline"><em>x</em><sub><em>i</em></sub></span> are changed into <span class="math inline"><em>c</em><sub><em>j</em></sub><sup>0</sup></span> and <span class="math inline"><em>x</em><sub><em>i</em></sub><sup>0</sup></span>. After this, variables and constants will be processed in the same way.</p>
<p>At this point, the equations we get are AREs (Affine Recurrence Equations), that is, every data flow (write after read dependence) has a distance vector in the form of <span class="math inline"><em>d</em> = <em>A</em><em>z</em> + <em>d</em><sub>0</sub></span>, where <span class="math inline"><em>A</em></span> is a matrix, <span class="math inline"><em>z</em></span> is the iteration indices, and <span class="math inline"><em>d</em><sub>0</sub></span> is a constant vector:</p>
<p><img src="./img/affine-deps-of-auto-regressive-filter.png" /></p>
<h2 data-number="2.5" id="step-5-ures"><span class="header-section-number">2.5</span> Step 5: UREs</h2>
<p>We translate AREs into UREs by converting a broadcast into a pipeline. After that, every dependence has a constant distance uniformly in the entire domain.</p>
<p>There are two ways to convert a broadcast into a pipeline. First, we can draw the dataflow and intuitively change a broadcast into a pipeline. Say <span class="math inline"><em>n</em> = 3</span>. We can draw the dataflow for the second dependence, as shown below to the left. Every point is an iteration, and annotated with the indices (<span class="math inline"><em>i</em>, <em>j</em></span>). A datum (<span class="math inline"><em>c</em><sub><em>j</em></sub><sup>0</sup></span>) is broadcast to iterations <span class="math inline"><em>y</em><sub><em>i</em></sub><sup><em>j</em></sup></span> for all <span class="math inline"><em>i</em></span>. Equivalently, we can send a datum to an iteration at a boundary of the domain, and from that iteration, propagate the datum in a pipeline fashion to all the other iterations, as shown below to the right.</p>
<p><img src="./img/broadcast-to-pipeline-arf.png" /></p>
<p>As we can see from the dataflow graph, a datum <span class="math inline"><em>c</em><sub><em>j</em></sub><sup>0</sup></span> is loaded at a bounary iteration <span class="math inline">(1,<em>j</em>)</span>, and then is propagated to iteration <span class="math inline">(2,<em>j</em>)</span>, and from there to iteration <span class="math inline">(3,<em>j</em>)</span>, etc. Therefore, we can modify the full index form</p>
<p>​ <span class="math inline"><em>y</em><sub><em>i</em></sub><sup><em>j</em></sup> = ...<em>c</em><sub><em>j</em></sub><sup>0</sup>...</span></p>
<p>into</p>
<p>​ <span class="math inline"><em>y</em><sub><em>i</em></sub><sup><em>j</em></sup> = ...<em>C</em><sub><em>i</em></sub><sup><em>j</em></sup>...</span></p>
<p>where</p>
<p>​ <span class="math inline"><em>C</em><sub><em>i</em></sub><sup><em>j</em></sup> = <em>C</em><sub><em>i</em> − 1</sub><sup><em>j</em></sup></span></p>
<p>with an initial condition</p>
<p>​ <span class="math inline"><em>C</em><sub><em>i</em> − 1</sub><sup><em>j</em></sup> = <em>c</em><sub><em>j</em></sub><sup>0</sup></span> when <span class="math inline"><em>i</em></span>=1</p>
<p>In the same way, we can convert a broadcast due to the third dependence into a pipeline. An exercise: Can you draw a dataflow graph and make it yourself? After that, we get the UREs shown in the above table.</p>
<p>Second, we can</p>
<p><img src="./img/broadcast-to-pipeline.png" /></p>
<p>slightly:</p>
<p>What is shown</p>
<p>In the above table, the second and third dependence are affine.</p>
<p>The first dependence is already uniformA uniform distance</p>
<p><span class="math inline">(<em>i</em>,<em>j</em>)<sup><em>T</em></sup><em>A</em><em>B</em><em>C</em> = minimum<em>X</em><em>Y</em><em>Z</em>, <em>Z</em><em>Y</em><em>X</em></span></p>
<p>There are still some</p>
<p>Of course, depending on the domain in a specific problem, one should</p>
<p>This is because the three occurences of the variable <span class="math inline"><em>y</em></span></p>
<p>. new value of variable <span class="math inline"><em>y</em><sub><em>i</em></sub></span> is assigned to a distinct memory location named <span class="math inline"><em>y</em><sub><em>i</em></sub><sup><em>j</em></sup></span>, and its reference to a previous value of variable <span class="math inline"><em>y</em><sub><em>i</em></sub></span> is changed to</p>
<p>This renaming</p>
<p>In the illustrated example, <span class="math inline"><em>y</em><sub><em>i</em></sub></span> is the result of a series of additions,</p>
<p>here it is</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Or so</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* or so */</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span> i<span class="op">&lt;</span> <span class="dv">99</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> j<span class="op">=</span><span class="dv">10</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// dkfjldjfl</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//lkdfjdsf</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>And after</p>
<p><a href="README.md#Design-for-Data-Buffering">for1</a></p>
<p><a href="#here-it-is">for2</a></p>
<h1 data-number="3" id="references"><span class="header-section-number">3</span> References</h1>
<p><a id="1">[1]</a> Marjan Gusev and David J. Evans. Algorithm Transformations for the Data Broadcast Elimination Method. Parallel Algorithm Research Centre. Loughborough University of Technology. Loughborough, Leicestershire LE11 3TU. Internal Report 646 Computer Department.</p>
<p><a id="2">[2]</a> Marjan Gusev and David J. Evans. Elimination of the Computational Broadcast : An Application to the QR Decomposition Algorithm. Parallel Algorithm Research Centre. Loughborough University of Technology. Loughborough, Leicestershire LE11 3TU. Internal Report 676 Computer Department.</p>
